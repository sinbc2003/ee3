<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>토론 플랫폼</title>
    <style>
      *, *::before, *::after { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: 'Pretendard', 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f4f6fb; color: #1f2937; overflow: hidden; }
      textarea, input, button { font-family: inherit; }
      .page-container { max-width: 1200px; margin: 0 auto; padding: 12px 20px 16px; display: flex; flex-direction: column; gap: 12px; height: 100%; box-sizing: border-box; overflow: hidden; }
      .card { background: #ffffff; border-radius: 14px; border: 1px solid #e2e8f0; padding: 24px; box-shadow: 0 8px 24px rgba(15, 23, 42, 0.06); }
      .hero-card { text-align: center; }
      .hero-card h1 { margin: 0 0 12px; font-size: 26px; font-weight: 700; color: #111827; }
      .hero-card p { margin: 0 0 18px; color: #4b5563; font-size: 15px; }
      .group-buttons { display: flex; justify-content: center; gap: 16px; flex-wrap: wrap; }
      .group-button { min-width: 160px; padding: 18px 20px; border-radius: 12px; border: 1px solid #d0d7e3; background: linear-gradient(135deg, #f8fafc, #eef2ff); font-weight: 700; font-size: 16px; color: #1d4ed8; cursor: pointer; transition: transform 0.18s ease, box-shadow 0.18s ease; }
      .group-button:hover { transform: translateY(-4px); box-shadow: 0 14px 26px rgba(37, 99, 235, 0.18); }
      .group-button:active { transform: translateY(-1px); }
      .type-card { max-width: 720px; margin: 0 auto; text-align: center; }
      .type-card p { margin: 10px 0 20px; color: #475569; font-size: 14px; }
      .type-buttons { display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; }
      .type-option { flex: 1; min-width: 220px; padding: 18px; border-radius: 14px; border: 1px solid #cbd5f5; background: #f8fafc; display: flex; flex-direction: column; gap: 6px; align-items: flex-start; text-align: left; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease; }
      .type-option:hover { transform: translateY(-2px); border-color: #94a3ff; }
      .type-option strong { font-size: 18px; color: #111827; }
      .type-option span { font-size: 13px; color: #475569; }
      .type-option.active { border-color: #2563eb; box-shadow: 0 12px 24px rgba(37, 99, 235, 0.2); background: #eef2ff; }
      .login-card { display: none; max-width: 520px; margin: 0 auto; }
      .login-header { display: flex; flex-direction: column; gap: 6px; margin-bottom: 18px; }
      .login-group-row { display: flex; align-items: center; gap: 8px; }
      .login-group-row .ghost { padding: 6px 10px; font-size: 12px; }
      .login-group { font-size: 18px; font-weight: 700; color: #1d4ed8; }
      .login-message { font-size: 13px; color: #64748b; }
      .login-card form { display: flex; flex-direction: column; gap: 16px; }
      .field { display: flex; flex-direction: column; gap: 6px; }
      label { font-size: 13px; font-weight: 600; color: #475569; }
      input[type="text"], textarea { width: 100%; border: 1px solid #d0d7e3; border-radius: 10px; padding: 12px; background: #ffffff; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
      input[type="text"]:focus, textarea:focus { border-color: #2563eb; outline: none; box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.12); }
      textarea { min-height: 180px; resize: vertical; line-height: 1.6; }
      button { cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease; }
      button:disabled { cursor: not-allowed; opacity: 0.6; box-shadow: none !important; transform: none !important; }
      .primary { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; border: none; border-radius: 10px; padding: 12px 18px; font-weight: 700; box-shadow: 0 8px 20px rgba(37, 99, 235, 0.25); }
      .primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 14px 28px rgba(37, 99, 235, 0.28); }
      .secondary { background: #f1f5f9; color: #1f2937; border: 1px solid #d0d7e3; border-radius: 10px; padding: 12px 18px; font-weight: 600; }
      .ghost { background: transparent; border: none; color: #2563eb; padding: 12px 16px; font-weight: 600; }
      .ghost:hover { text-decoration: underline; }
      .link-button { background: none; border: none; color: #2563eb; font-weight: 600; padding: 8px 12px; border-radius: 8px; }
      .link-button:hover { background: rgba(37, 99, 235, 0.1); }
      .login-actions { display: flex; gap: 12px; justify-content: flex-end; }
      .workspace { display: none; flex-direction: column; gap: 12px; flex: 1; overflow: hidden; min-height: 0; }
      .workspace-toolbar { display: flex; justify-content: space-between; align-items: center; gap: 12px; padding: 4px 0; }
      .user-info { font-size: 14px; font-weight: 600; color: #475569; }
      .status-bar { padding: 10px 14px; border-radius: 12px; border: 1px solid #cbd5f5; background: #eef2ff; color: #1e3a8a; font-size: 13px; line-height: 1.4; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4); }
      .status-bar.success { border-color: #bbf7d0; background: #ecfdf5; color: #047857; }
      .status-bar.warn { border-color: #fde68a; background: #fef3c7; color: #92400e; }
      .status-bar.error { border-color: #fecaca; background: #fee2e2; color: #b91c1c; }
      .step-indicator { display: flex; gap: 12px; flex-wrap: wrap; }
      .step-item { flex: 1; min-width: 150px; display: flex; align-items: center; gap: 10px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 10px 12px; transition: border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease; }
      .step-number { min-width: 36px; padding: 0 6px; height: 32px; border-radius: 999px; background: #e2e8f0; color: #1f2937; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 13px; }
      .step-info { display: flex; flex-direction: column; gap: 2px; }
      .step-title { font-size: 14px; font-weight: 700; color: #1f2937; }
      .step-caption { font-size: 12px; color: #64748b; }
      .step-item.active { border-color: #2563eb; transform: translateY(-2px); box-shadow: 0 14px 26px rgba(37, 99, 235, 0.16); }
      .step-item.active .step-number { background: #2563eb; color: #ffffff; }
      .step-item.completed { border-color: #bbf7d0; }
      .step-item.completed .step-number { background: #10b981; color: #ffffff; }
      .workspace-grid { display: grid; gap: 16px; grid-template-columns: 1.1fr 0.9fr; flex: 1; min-height: 0; height: 100%; }
      .left-column, .right-column { display: flex; flex-direction: column; gap: 14px; min-height: 0; height: 100%; overflow-y: auto; padding-right: 6px; }
      .stage-panel { background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 18px; display: flex; flex-direction: column; gap: 12px; }
      .panel-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
      .panel-header h2 { font-size: 18px; font-weight: 700; margin: 0; color: #111827; white-space: nowrap; }
      .panel-subtext { font-size: 13px; color: #64748b; }
      .readonly-block { display: none; padding: 12px; border-radius: 10px; border: 1px dashed #cbd5e1; background: #f8fafc; font-size: 14px; line-height: 1.7; color: #1f2937; white-space: pre-wrap; }
      .text-block { padding: 12px; border-radius: 10px; border: 1px solid #d8dee9; background: #f8fafc; font-size: 14px; line-height: 1.7; white-space: pre-wrap; color: #1f2937; }
      .button-row { display: flex; gap: 10px; justify-content: flex-end; }
      .meta-info { font-size: 12px; color: #64748b; }
      .right-panel { display: none; flex-direction: column; gap: 12px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 18px; min-height: 360px; flex: none; overflow: visible; }
      .dictionary-search { display: flex; gap: 10px; }
      .dictionary-result { padding: 14px; border-radius: 10px; border: 1px solid #cbd5e1; background: #f8fafc; display: flex; flex-direction: column; gap: 8px; }
      .dict-word { font-size: 18px; font-weight: 700; color: #111827; }
      .dict-pron { font-size: 13px; color: #64748b; }
      .dict-section { display: flex; flex-direction: column; gap: 6px; }
      .dict-entry { padding: 8px 10px; border-radius: 8px; background: #fff; border: 1px solid #e2e8f0; }
      .dict-entry strong { font-size: 13px; color: #1f2937; }
      .dict-examples { display: flex; flex-direction: column; gap: 6px; }
      .dict-example { padding: 8px 10px; border-radius: 8px; background: #fff; border: 1px solid #e2e8f0; font-size: 13px; line-height: 1.5; }
      .dictionary-history { display: flex; flex-direction: column; gap: 8px; font-size: 13px; color: #64748b; }
      .history-item { display: flex; gap: 8px; align-items: center; padding: 10px 12px; border-radius: 10px; background: #f8fafc; border: 1px solid #e2e8f0; }
      .history-item .term { font-weight: 600; color: #1f2937; }
      .history-item .direction { font-weight: 600; color: #475569; }
      .history-item .translation { color: #2563eb; }
      .history-item .time { margin-left: auto; color: #94a3b8; font-size: 12px; }
      .prewriting-preview-block { display: flex; flex-direction: column; gap: 6px; }
      .prewriting-preview-block strong { font-size: 13px; color: #475569; }
      .stage3-preview-grid { display: flex; flex-direction: column; gap: 14px; }
      .stage3-transcript-block { border: 1px dashed #d0d7f3; background: #f5f8ff; border-radius: 10px; padding: 12px; }
      .stage3-transcript-list { display: flex; flex-direction: column; gap: 8px; max-height: 280px; overflow-y: auto; }
      .stage3-transcript-line { padding: 10px 12px; border-radius: 10px; border: 1px solid #dfe3f8; background: #fff; font-size: 13px; line-height: 1.45; color: #1f2937; }
      .stage3-transcript-line.ai { background: #eef2ff; border-color: #c7d2fe; }
      .stage3-transcript-line .label { display: block; font-weight: 600; color: #4338ca; margin-bottom: 4px; font-size: 12px; }
      .stage3-memo-helper { font-size: 12px; color: #6b7280; margin: -4px 0 0; }
      .chat-log { flex: 1; min-height: 320px; max-height: 320px; border: 1px solid #d0d7e3; border-radius: 12px; background: radial-gradient(circle at top, #f8fafc 0%, #ffffff 48%); padding: 12px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
      .chat-line { display: flex; flex-direction: column; gap: 4px; max-width: 80%; word-break: break-word; }
      .chat-line.me { align-self: flex-end; text-align: right; }
      .chat-line.ai, .chat-line.other { align-self: flex-start; }
      .chat-line.system { align-self: center; max-width: 100%; text-align: center; }
      .chat-bubble { padding: 10px 14px; border-radius: 14px; line-height: 1.6; background: #eef2ff; color: #1f2937; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08); }
      .chat-line.me .chat-bubble { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; border-bottom-right-radius: 6px; }
      .chat-line.ai .chat-bubble { background: #f8fafc; border: 1px solid #cbd5f5; border-bottom-left-radius: 6px; }
      .chat-line.system .chat-bubble { background: #f1f5f9; color: #475569; border: 1px dashed #cbd5e1; }
      .chat-meta { font-size: 11px; color: #94a3b8; }
      .chat-line.me .chat-meta { align-self: flex-end; }
      .chat-line.pending .chat-meta::after { content: ' · 전송 중'; color: #f97316; }
      .chat-line.error .chat-bubble { border: 1px solid #f87171; }
      .chat-input { display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }
      .chat-input textarea { height: 96px; min-height: 96px; max-height: 96px; resize: none; overflow-y: auto; }
      #aiInput { height: 72px; min-height: 72px; max-height: 72px; }
      #notesInput { min-height: 90px; height: 90px; }
      #finalInput { min-height: 260px; }
      .chat-actions { display: flex; justify-content: flex-end; gap: 10px; }
      .spinner { display: none; align-items: center; gap: 8px; font-size: 13px; color: #64748b; }
      .partner-box { border: 1px solid #d0d7e3; border-radius: 12px; padding: 12px 14px; background: linear-gradient(135deg, #f8fafc, #f1f5f9); display: flex; flex-direction: column; gap: 6px; }
      .partner-box h3 { margin: 0; font-size: 16px; font-weight: 700; color: #1f2937; }
      .partner-meta { font-size: 12px; color: #64748b; }
      .presence-status { display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: #475569; }
      .presence-status span { display: flex; align-items: center; gap: 6px; }
      .presence-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
      .presence-online { background: #22c55e; }
      .presence-offline { background: #94a3b8; }
      .notes-helper { font-size: 12px; color: #94a3b8; }
      .final-grid { display: grid; gap: 12px; }
      @media (max-width: 1024px) {
        .workspace-grid { grid-template-columns: 1fr; }
        .right-column { order: -1; }
      }
      @media (max-width: 640px) {
        .page-container { padding: 12px 14px 16px; }
        .group-buttons { flex-direction: column; }
        .login-actions { flex-direction: column; align-items: stretch; }
        .step-item { min-width: 100%; }
        .chat-log { max-height: none; min-height: 260px; }
        .left-column { padding-right: 0; }
        .chat-input textarea { height: 90px; min-height: 90px; max-height: 90px; }
        #aiInput { height: 68px; min-height: 68px; max-height: 68px; }
        #finalInput { min-height: 200px; }
      }
      .chat-line.me .chat-content { align-items: flex-end; }
      .chat-line.ai.with-avatar { flex-direction: row; gap: 10px; max-width: 80%; }
      .chat-line.ai.with-avatar .chat-content { max-width: calc(100% - 48px); }
      .chat-line.ai.with-avatar .chat-meta { align-self: flex-start; }
      .chat-avatar { width: 36px; height: 36px; border-radius: 50%; background-size: cover; background-position: center; border: 1px solid #e2e8f0; flex-shrink: 0; margin-top: 2px; }
      .reference-block { border: 1px solid #e2e8f0; border-radius: 10px; background: #f8fafc; padding: 12px; display: flex; flex-direction: column; gap: 8px; }
      .reference-block strong { font-size: 13px; color: #1f2937; }
      .panel-block { display: flex; flex-direction: column; gap: 12px; margin-bottom: 18px; }
      .panel-block:last-of-type { margin-bottom: 0; }
      #rightStage1 { background: transparent; border: none; padding: 0; min-height: auto; }
      #rightStage1 .stage-panel { margin: 0; }
    </style>
    <script src="./app-config.js"></script>
  </head>
  <body>
    <div class="page-container">
      <div id="typeCard" class="card type-card">
        <h1>학습 Type을 선택하세요</h1>
        <p>Type A는 기존 토론/AI 결합형 흐름이며, Type B는 1~5차시 중 3·4차시가 세부 단계(3-1/3-2, 4-1/4-2)로 구성됩니다.</p>
        <div class="type-buttons">
          <button class="type-option active" data-type-option="TYPE_A">
            <strong>Type A</strong>
            <span>현재 사용 중인 토론/AI 결합형 단계</span>
          </button>
          <button class="type-option" data-type-option="TYPE_B">
            <strong>Type B</strong>
            <span>3·4차시가 2단계로 세분화된 확장형 흐름</span>
          </button>
        </div>
      </div>

      <div id="loginCard" class="card login-card">
        <div class="login-header">
          <div class="login-group-row">
            <div id="selectedTypeLabel" class="login-group">Type A · 기본</div>
            <button id="btnChangeType" class="ghost" type="button">타입 변경</button>
          </div>
          <div id="loginMessage" class="login-message">식별번호와 이름을 정확하게 입력해주세요.</div>
        </div>
        <form id="loginForm">
          <div class="field">
            <label for="studentIdInput">식별 번호</label>
            <input id="studentIdInput" type="text" placeholder="예) A10100" autocomplete="off" />
          </div>
          <div class="field">
            <label for="studentNameInput">이름</label>
            <input id="studentNameInput" type="text" placeholder="이름을 입력하세요" autocomplete="off" />
          </div>
          <div class="login-actions">
            <button id="loginSubmit" class="primary" type="submit">실험 시작</button>
          </div>
        </form>
      </div>

      <div id="workspace" class="workspace">
        <div class="workspace-toolbar">
          <div id="userInfo" class="user-info"></div>
          <button id="btnRestart" class="link-button" type="button">처음으로 돌아가기</button>
          </div>
        <div id="statusBar" class="status-bar info">식별 번호와 이름을 입력하면 세션이 시작됩니다.</div>
        <div id="stepIndicator" class="step-indicator">
        </div>

        <div class="workspace-grid">
          <div class="left-column">
            <section id="panelPrompt" class="stage-panel" data-step="1">
              <div class="panel-header">
                <h2 id="promptStageTitle">2차시 · 토론 관련 발문</h2>
                <span id="promptStageSubtitle" class="panel-subtext">논제 이해를 위해 핵심 발문을 확인하세요. 필요 시 교사가 제시합니다.</span>
              </div>
              <div id="promptContent" class="text-block">토론 발문이 아직 등록되지 않았습니다.</div>
            </section>

            <section id="panelPrewriting" class="stage-panel" data-step="1">
              <div class="panel-header">
                <h2 id="prewritingTitle">2차시 · 메모장</h2>
                <span id="prewritingInfo" class="panel-subtext">인터넷 검색으로 찬성·반대 근거를 수집하며 메모를 남기세요.</span>
              </div>
              <textarea id="prewritingInput" placeholder="주장·근거, 출처, 의문점을 자유롭게 적어 두세요."></textarea>
              <div id="prewritingReadonly" class="readonly-block"></div>
              <div class="button-row">
                <button id="btnPreSubmit" class="primary" type="button" disabled>2차시 메모 저장</button>
              </div>
            </section>

            <section id="panelDraft" class="stage-panel" data-step="2">
              <div class="panel-header">
                <h2 id="draftTitle">3-1차시 · 토론 메모</h2>
                <span id="draftInfo" class="panel-subtext">ChatGPT와 1:1 모의 토론 중 떠오른 주장·근거·반론을 간단히 메모하세요.</span>
              </div>
              <div class="prewriting-preview-block">
                <strong>토론 관련 발문</strong>
                <div id="draftPromptContent" class="text-block">관리자가 등록한 발문이 여기에 표시됩니다.</div>
              </div>
              <div class="prewriting-preview-block">
                <strong>이전 메모/발문</strong>
                <div id="prewritingPreview" class="text-block">2차시 메모가 아직 저장되지 않았습니다.</div>
              </div>
              <textarea id="draftInput" placeholder="찬성/반대 주장, 근거, 추가 조사할 내용 등을 기록하세요."></textarea>
              <div class="button-row">
                <button id="btnDraftBack" class="ghost" type="button">이전 단계로 이동</button>
                <button id="btnSaveDraft" class="secondary" type="button" disabled>3-1차시 메모 저장</button>
                <button id="btnToPeer" class="primary" type="button" disabled>다음 단계로 이동</button>
              </div>
            </section>

            <section id="panelMemoStage3" class="stage-panel" data-step="3">
              <div class="panel-header">
                <h2 id="memoStage3Title">글쓰기 수정 관련 메모</h2>
                <span id="memoStage3Info" class="panel-subtext">동료의 글을 읽고, 10분 동안 어떤 피드백을 줄지 생각해 보세요. 피드백 내용을 메모 형태로 자유롭게 정리하세요. 동료에게서 받은 피드백을 참고하여, 글을 어떻게 수정할지에 대한 아이디어를 메모 형태로 자유롭게 정리하세요.</span>
              </div>
              <div class="stage3-preview-grid">
                <div class="stage3-transcript-block">
                  <strong id="stage3TranscriptHeading">3-1차시 토론 기록</strong>
                  <div id="stage3Transcript" class="stage3-transcript-list">
                    <div class="stage3-transcript-line">이전 토론 기록을 불러오는 중입니다.</div>
                  </div>
                </div>
                <div>
                  <label for="notesInput">질문/아이디어 메모</label>
                  <textarea id="notesInput" placeholder="3-1차시 토론을 다시 읽고, 궁금한 점이나 보완할 논거를 메모하세요." disabled></textarea>
                  <p id="stage3MemoHelper" class="stage3-memo-helper">먼저 기록을 보고 핵심 반론·보완점을 정리한 뒤, 오른쪽 AI 평가 패널에 질문을 던져 보세요.</p>
                </div>
              </div>
              <div class="button-row">
                <button id="btnStage3Back" class="ghost" type="button">이전 단계로 이동</button>
                <button id="btnNotesSave" class="secondary" type="button" disabled>3단계 메모 저장</button>
                <button id="btnPeerNext" class="primary" type="button" disabled>최종 단계로 이동</button>
              </div>
            </section>

            <section id="panelFinalSummary" class="stage-panel" data-step="4">
              <div class="panel-header">
                <h2 id="stage4Title">4차시 · 토론 발문</h2>
                <span id="stage4Subtitle" class="panel-subtext">관리자가 입력한 2차 토론 관련 발문을 확인하세요.</span>
              </div>
              <div id="stage4PromptContent" class="text-block">관리자가 등록한 발문이 여기에 표시됩니다.</div>
            </section>

            <section id="panelStage5" class="stage-panel" data-step="5">
              <div class="panel-header">
                <h2 id="stage5Title">5차시 · 4-1 토론 요약 & 메모 (4-2)</h2>
                <span id="stage5Subtitle" class="panel-subtext">4-1차시 대화를 요약해 확인하고, 추가로 메모하세요.</span>
              </div>
              <div class="prewriting-preview-block">
                <strong>4-1차시 토론 요약</strong>
                <div id="stage5TranscriptSummary" class="text-block">4-1 토론 기록을 불러오는 중입니다. (추후 연동)</div>
              </div>
              <textarea id="stage5MemoInput" placeholder="추가로 정리하고 싶은 내용을 메모하세요. (현재는 로컬에만 저장됩니다.)"></textarea>
              <div class="button-row">
                <button id="btnStage5MemoSave" class="secondary" type="button" disabled>5차시 메모 저장</button>
              </div>
            </section>
          </div>

          <div class="right-column">
            <section id="rightStage2" class="right-panel">
              <div class="panel-header">
                <h2 id="aiStageTitle">ChatGPT 모의 토론 (gpt-4.1-mini)</h2>
                <span id="aiStageSubtitle" class="panel-subtext">찬·반 입장으로 질문하며 논거를 점검하세요. 정답 생성 대신 토론 연습에 집중합니다.</span>
              </div>
              <div class="chat-log" id="aiChatLog"></div>
              <div id="aiChatLoader" class="spinner"><span>AI 응답 생성 중...</span></div>
              <div class="chat-input">
                <textarea id="aiInput" placeholder="AI에게 질문하거나 피드백을 요청하세요." disabled></textarea>
                <div class="chat-actions">
                  <button id="btnAiSend" class="primary" type="button" disabled>전송</button>
          </div>
        </div>
            </section>

            <section id="rightStage3" class="right-panel">
              <div class="panel-header">
                <h2 id="peerStageTitle">동료 피드백</h2>
                <span id="peerStageSubtitle" class="panel-subtext">동료와 15분간 상호작용하며 자신의 글에 대한 피드백을 받아 보세요. 동료에게 글을 대신 써달라고 요청하는 것은 안 됩니다.</span>
              </div>
               <div class="partner-box">
                 <h3 id="partnerName">동료 정보를 불러오는 중...</h3>
                 <div id="partnerInfoBox" class="partner-meta">동료 협업 단계입니다.</div>
      </div>
               <div class="presence-status">
                 <span><span id="selfPresenceDot" class="presence-dot presence-offline"></span>나의 상태: <span id="peerPresenceSelf">확인 중...</span></span>
                 <span><span id="partnerPresenceDot" class="presence-dot presence-offline"></span>동료 상태: <span id="peerPresencePartner">확인 중...</span></span>
          </div>
               <div class="chat-log" id="peerChatLog"></div>
               <div class="chat-input">
                 <textarea id="peerInput" placeholder="동료에게 메시지를 보내보세요." disabled></textarea>
                 <div class="chat-actions">
                   <button id="btnPeerSend" class="primary" type="button" disabled>전송</button>
                 </div>
               </div>
             </section>

            <section id="rightStage4" class="right-panel">
              <div class="panel-header">
                <h2 id="finalStageTitle">ChatGPT와 토론 (gpt-4.1-mini)</h2>
                <span id="finalStageSubtitle" class="panel-subtext">관리자 시스템 프롬프트를 기반으로 토론을 진행합니다.</span>
              </div>
              <div class="chat-log" id="finalChatLog"></div>
              <div id="finalChatLoader" class="spinner"><span>AI 응답 생성 중...</span></div>
              <div class="chat-input">
                <textarea id="finalChatInput" placeholder="질문하거나 토론을 이어가세요." disabled></textarea>
                <div class="chat-actions">
                  <button id="btnFinalChatSend" class="primary" type="button" disabled>전송</button>
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(){
        'use strict';

        const APP_CONFIG = window.APP_CONFIG || { apiBaseUrl: '/api', apiKey: '' };
        const TYPE_KEYS = { TYPE_A: 'TYPE_A', TYPE_B: 'TYPE_B' };
        const DEFAULT_TYPE = TYPE_KEYS.TYPE_A;
        const TYPE_CONFIGS = {
          [TYPE_KEYS.TYPE_A]: {
            id: TYPE_KEYS.TYPE_A,
            label: 'Type A · 기존 흐름',
            description: '2차시~5차시 구성 (AI/동료 토론 통합)',
            group: 'A',
            aiStages: [1, 2, 3, 4, 5],
            peerStages: [3],
            stepTemplate: [
              { badge: '1', stage: 1 },
              { badge: '2', stage: 2 },
              { badge: '3', stage: 3 },
              { badge: '4', stage: 4 },
              { badge: '5', stage: 5 },
            ],
          },
          [TYPE_KEYS.TYPE_B]: {
            id: TYPE_KEYS.TYPE_B,
            label: 'Type B · 세분화 흐름',
            description: '1~5차시 중 3·4차시가 2단계로 분리',
            group: 'B',
            aiStages: [2, 3, 4, 5],
            peerStages: [1, 3],
            stepTemplate: [
              { badge: '1', stage: 1, titleOverride: '1차시' },
              { badge: '2', stage: 2, titleOverride: '2차시' },
              { badge: '3-1', stage: 3, segment: 'a', titleOverride: '3-1차시' },
              { badge: '3-2', stage: 4, segment: 'b', titleOverride: '3-2차시' },
              { badge: '4-1', stage: 5, segment: 'a', titleOverride: '4-1차시' },
              { badge: '4-2', stage: 5, segment: 'b', titleOverride: '4-2차시' },
            ],
          },
        };
        const DEFAULT_STAGE_LABELS_BY_TYPE = {
          [TYPE_KEYS.TYPE_A]: [
          { name: '2차시', headline: '논거 점검', description: '찬·반 입장으로 질문하며 논거를 점검하세요. 정답 생성 대신 토론 연습에 집중합니다.' },
          { name: '3차시-1', headline: 'ChatGPT 모의 토론 (gpt-4.1-mini)', description: 'AI와 토론을 이어가며 핵심 반론과 근거를 정리하세요.' },
          { name: '3차시-2', headline: '동료 토론', description: '동료와 상호 피드백을 주고받으며 글을 다듬으세요.' },
          { name: '4차시-1', headline: '4-1차시 토론 발문', description: '관리자가 제공한 발문을 다시 확인하고 논리를 점검하세요.' },
          { name: '4차시-2', headline: '4-2차시 정리', description: '4-1차시 대화를 요약하고 추가 메모를 정리하세요.' },
          ],
          [TYPE_KEYS.TYPE_B]: [
            { name: '1차시', headline: '주제 탐구', description: '배경 지식을 모으고 주제를 이해합니다.' },
            { name: '2차시', headline: '관점 정리', description: '찬성/반대 관점을 나누어 근거를 정리합니다.' },
            { name: '3차시', headline: '3-1/3-2 토론', description: 'AI와 토론하며 떠오르는 질문을 기록합니다.' },
            { name: '4차시', headline: '4-1/4-2 평가', description: 'AI 피드백을 바탕으로 논리를 보완합니다.' },
            { name: '5차시', headline: '최종 정리', description: '핵심 주장과 후속 과제를 정리합니다.' },
          ],
        };
        const DEFAULT_STAGE_PROMPTS_BY_TYPE = {
          [TYPE_KEYS.TYPE_A]: [
          {
            reference: '찬·반 논거를 조사하며 핵심 근거와 반론거리를 메모하세요. AI 웹검색을 활용해 다양한 출처를 탐색해 보세요.',
            aiPrompt: '당신은 학생의 토론 준비를 돕는 AI 웹연구 도우미입니다. 학생이 던지는 질문에 대해, 공정하게 찬성과 반대 측 근거를 모두 제시하고, 신뢰할 만한 출처 정보도 간단히 언급하세요. 답변은 핵심 bullet 2~3개 중심으로, 쉬운 문장으로 작성합니다.',
          },
          {
            reference: 'ChatGPT와 모의 토론을 진행하며 찬성/반대 입장에서 나올 수 있는 반론을 미리 점검하세요.',
            aiPrompt: '당신은 학생과 토론을 진행하는 AI 멘토입니다. 학생의 주장에 근거를 요구하거나 빈틈을 짚어 주고, 설득력 있는 사례와 데이터로 논리를 강화하도록 유도하세요.',
          },
          { reference: '동료에게 줄 피드백 포인트를 메모하세요.', aiPrompt: '' },
          {
            reference: '4-1차시 토론 발문을 확인하고, AI와 심층 토론을 이어가세요. 주장·근거·반론을 명확하게 정리해 보세요.',
            aiPrompt: '당신은 학생의 최종 주장을 검토하는 AI 멘토입니다. 학생의 근거에 비판적 질문을 던지고, 더 정교한 논리를 완성하도록 도와주세요.',
          },
          { reference: '4-1차시 대화를 요약하고, 최종 주장을 정리하세요.', aiPrompt: '' },
          ],
          [TYPE_KEYS.TYPE_B]: [
            {
              reference: '주제 이해를 위해 핵심 키워드·배경 정보를 정리하세요.',
              aiPrompt: '학생이 놓친 배경 정보를 제시하고, 더 조사할 지점을 제안해 주세요.',
            },
            {
              reference: '찬/반 주장의 핵심 근거를 각각 2가지 이상 작성하세요.',
              aiPrompt: '양측 논거의 취약점을 짚고, 보완할 데이터를 제안해 주세요.',
            },
            {
              reference: '3-1/3-2 단계에서 사용할 질문 또는 반론을 메모하세요.',
              aiPrompt: '학생의 질문을 바탕으로 더 깊은 토론이 이뤄지도록 후속 질문을 던져 주세요.',
            },
            {
              reference: 'AI 피드백을 요약하고, 추가로 확인할 근거를 적어두세요.',
              aiPrompt: '학생의 주장에 논리적 빈틈이 없도록 점검하고 구체적 수정 방향을 제안하세요.',
            },
            {
              reference: '최종 주장을 요약하고, 다음 활동을 위한 체크리스트를 작성하세요.',
              aiPrompt: '',
            },
          ],
        };

        function normalizeApiBaseUrl(path){
          if (!path) return `${window.location.origin}/api/`;
          const trimmed = String(path).trim();
          if (/^https?:\/\//i.test(trimmed)) {
            return trimmed.endsWith('/') ? trimmed : `${trimmed}/`;
          }
          const prefixed = trimmed.startsWith('/') ? trimmed : `/${trimmed}`;
          const combined = `${window.location.origin}${prefixed}`;
          return combined.endsWith('/') ? combined : `${combined}/`;
        }

        function createBackendClient(config){
          const baseUrl = normalizeApiBaseUrl(config.apiBaseUrl || '/api');
          const apiKey = config.apiKey || '';

          async function request(method, path, options){
            const opts = options || {};
            const url = new URL(path, baseUrl);
            if (opts.searchParams){
              Object.entries(opts.searchParams).forEach(function([key, value]){
                if (value === undefined || value === null || value === '') return;
                url.searchParams.set(key, value);
              });
            }
            const headers = { 'Content-Type': 'application/json' };
            if (apiKey) headers['x-api-key'] = apiKey;
            const fetchOptions = { method: method.toUpperCase(), headers };
            if (opts.body && fetchOptions.method !== 'GET') {
              fetchOptions.body = JSON.stringify(opts.body);
            }
            const response = await fetch(url.toString(), fetchOptions);
            if (response.status === 204) return null;
            const text = await response.text();
            let payload = null;
            if (text) {
              try {
                payload = JSON.parse(text);
              } catch (err) {
                console.error('서버 응답 파싱 실패', err, text);
                throw new Error('서버 응답을 읽을 수 없습니다.');
              }
            }
            if (!response.ok) {
              const message = (payload && (payload.error || payload.message)) || response.statusText;
              const error = new Error(message || '요청에 실패했습니다.');
              error.status = response.status;
              error.details = payload;
              throw error;
            }
            return payload;
          }

          return {
            isReady: true,
            getServerDiag: function(){ return request('GET', 'server/diag'); },
            getPublicSettings: function(){ return request('GET', 'public-settings'); },
            startSession: function(group, studentId, studentName){
              return request('POST', 'session/start', { body: { group, studentId, studentName } });
            },
            getSessionState: function(sessionKey){
              return request('GET', `session/${encodeURIComponent(sessionKey)}`);
            },
            submitPrewriting: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/prewriting`, { body: { text } });
            },
            savePostDraft: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/draft`, { body: { text } });
            },
            savePeerNotes: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/notes`, { body: { text } });
            },
            submitFinalWriting: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/final`, { body: { text } });
            },
            advanceToPeerStage: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/advance`);
            },
            advanceToFinalStage: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/advance-final`);
            },
            jumpToStage: function(sessionKey, stage){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/jump`, { body: { stage } });
            },
            regressStage: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/regress`);
            },
            touchPresence: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/presence/touch`);
            },
            postPresenceLeave: function(sessionKey, userId, userName){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/presence/leave`, { body: { userId, userName } });
            },
            getMessages: function(sessionId, sinceTs, channel){
              return request('GET', `chat/${encodeURIComponent(channel)}/messages`, { searchParams: { sessionId, since: sinceTs } });
            },
            postMessage: function(sessionId, group, userId, userName, role, text, metadata){
              const channel = (metadata && metadata.channel) || 'ai-feedback';
              return request('POST', `chat/${encodeURIComponent(channel)}/send`, {
                body: { sessionId, group, userId, userName, role, text, metadata }
              });
            },
            requestAiIfNeeded: function(sessionId, group, userMessage, context, metadata){
              return request('POST', 'chat/ai/respond', { body: { sessionId, group, userMessage, context, metadata } });
            },
            lookupDictionary: function(query){
              return request('GET', 'dictionary', { searchParams: { q: query } });
            }
          };
        }

        function createRunner(api, handlers){
          const currentHandlers = handlers || {};
          return new Proxy({}, {
            get: function(_target, prop){
              if (prop === 'withSuccessHandler') {
                return function(fn){ return createRunner(api, Object.assign({}, currentHandlers, { success: fn })); };
              }
              if (prop === 'withFailureHandler') {
                return function(fn){ return createRunner(api, Object.assign({}, currentHandlers, { failure: fn })); };
              }
              if (typeof api[prop] === 'function') {
                return function(){
                  const args = Array.prototype.slice.call(arguments);
                  return api[prop].apply(api, args)
                    .then(function(result){
                      if (typeof currentHandlers.success === 'function') currentHandlers.success(result);
                      return result;
                    })
                    .catch(function(error){
                      if (typeof currentHandlers.failure === 'function') {
                        currentHandlers.failure(error);
                        return;
                      }
                      console.error(error);
                    });
                };
              }
              return undefined;
            }
          });
        }

        function createGoogleScriptRunShim(api){
          return createRunner(api, {});
        }

        const backend = createBackendClient(APP_CONFIG);
        const google = window.google = window.google || {};
        google.script = google.script || {};
        google.script.run = createGoogleScriptRunShim(backend);
        const hasGas = Boolean(backend && backend.isReady);

        const DEFAULT_AI_AVATAR = '/chatgpt.png';

        const state = {
          typeMode: DEFAULT_TYPE,
          group: TYPE_CONFIGS[DEFAULT_TYPE].group,
          sessionKey: '',
          user: { id: '', name: '' },
          stage: 1,
          updatedAt: 0,
          stageChangePending: false,
          writing: {
            prewriting: { text: '', submittedAt: 0 },
            draft: { text: '', savedAt: 0 },
            notes: { text: '', updatedAt: 0 },
            final: { text: '', submittedAt: 0 }
          },
          steps: {},
          partner: null,
          presence: null,
          status: { message: '식별 번호와 이름을 입력하면 세션이 시작됩니다.', type: 'info' },
          aiChat: { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false, awaitingResponse: false, welcomeShown: false },
          peerChat: { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false },
          aiStageLogs: {},
          aiTranscriptKeys: {},
          currentAiStage: 0,
          timers: { ai: null, peer: null, state: null, presence: null },
          refreshingState: false,
          dictionaryHistory: [],
          localPrewritingDraft: '',
          localFinalDraft: '',
          localDraftBuffer: '',
          localStage3Memo: '',
          localStage5Memo: '',
          aiAvatarUrl: DEFAULT_AI_AVATAR
        };

        const $ = (id) => document.getElementById(id);
        const publicConfig = {
          aiAvatarUrl: DEFAULT_AI_AVATAR,
          promptContent: '',
          stageLabelsByType: {
            [TYPE_KEYS.TYPE_A]: DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A].map((label) => ({ ...label })),
            [TYPE_KEYS.TYPE_B]: DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_B].map((label) => ({ ...label })),
          },
          stagePromptsByType: {
            [TYPE_KEYS.TYPE_A]: DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A].map((prompt) => ({ ...prompt })),
            [TYPE_KEYS.TYPE_B]: DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_B].map((prompt) => ({ ...prompt })),
          },
        };

        function normalizeStageLabels(list, fallbackList){
          const baseList =
            (Array.isArray(fallbackList) && fallbackList.length ? fallbackList : DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A]) ||
            [];
          return baseList.map((label, idx) => {
            const incoming = Array.isArray(list) && list[idx] ? list[idx] : {};
            return {
              name: typeof incoming.name === 'string' ? incoming.name.trim() || label.name : label.name,
              headline: typeof incoming.headline === 'string' ? incoming.headline.trim() || label.headline : label.headline,
              description:
                typeof incoming.description === 'string'
                  ? incoming.description.trim() || label.description
                  : label.description,
            };
          });
        }

        function getStageLabelsForType(typeKey){
          const key = TYPE_CONFIGS[typeKey] ? typeKey : TYPE_KEYS.TYPE_A;
          const stored = publicConfig.stageLabelsByType[key];
          if (Array.isArray(stored) && stored.length) return stored;
          return DEFAULT_STAGE_LABELS_BY_TYPE[key] || DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A];
        }

        function getStageLabel(stageNumber){
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const labels = getStageLabelsForType(typeKey);
          const index = Math.max(0, Math.min(labels.length - 1, Number(stageNumber || 1) - 1));
          return labels[index] || labels[0];
        }

        function normalizeStagePrompts(list, fallbackList){
          const baseList =
            (Array.isArray(fallbackList) && fallbackList.length ? fallbackList : DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A]) ||
            [];
          return baseList.map((prompt, idx) => {
            const incoming = Array.isArray(list) && list[idx] ? list[idx] : {};
            return {
              reference:
                typeof incoming.reference === 'string'
                  ? incoming.reference
                  : typeof prompt.reference === 'string'
                    ? prompt.reference
                    : '',
              aiPrompt:
                typeof incoming.aiPrompt === 'string'
                  ? incoming.aiPrompt
                  : typeof prompt.aiPrompt === 'string'
                    ? prompt.aiPrompt
                    : '',
            };
          });
        }

        function getStagePromptsForType(typeKey){
          const key = TYPE_CONFIGS[typeKey] ? typeKey : TYPE_KEYS.TYPE_A;
          const stored = publicConfig.stagePromptsByType[key];
          if (Array.isArray(stored) && stored.length) return stored;
          return DEFAULT_STAGE_PROMPTS_BY_TYPE[key] || DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A];
        }

        function getStagePromptData(stageNumber){
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const prompts = getStagePromptsForType(typeKey);
          const index = Math.max(0, Math.min(prompts.length - 1, Number(stageNumber || 1) - 1));
          return prompts[index] || prompts[0];
        }

        function setRichText(id, text, fallback){
          const el = $(id);
          if (!el) return;
          const content = String(text || '').trim();
          if (!content) {
            el.innerHTML = fallback || '';
            return;
          }
          el.innerHTML = escapeHtml(content).replace(/\n/g, '<br/>');
        }

        function getTypeConfig(typeKey){
          return TYPE_CONFIGS[typeKey] || TYPE_CONFIGS[TYPE_KEYS.TYPE_A];
        }

        function mapGroupToTypeKey(group){
          return String(group || '').toUpperCase() === 'B' ? TYPE_KEYS.TYPE_B : TYPE_KEYS.TYPE_A;
        }

        function setTypeMode(typeKey, options){
          const opts = options || {};
          const config = getTypeConfig(typeKey);
          const prevType = state.typeMode;
          state.typeMode = config.id;
          state.group = config.group;
          if (!opts.silent || !prevType || prevType !== config.id) {
            updateSelectedTypeLabel();
            highlightTypeButtons();
          }
          buildStepIndicator();
          if (opts.skipWorkspace) {
            updateStepIndicator();
            return;
          }
          renderWorkspace();
        }

        function updateSelectedTypeLabel(){
          const label = $('selectedTypeLabel');
          if (!label) return;
          const config = getTypeConfig(state.typeMode);
          label.textContent = config.label || 'Type A';
        }

        function highlightTypeButtons(){
          const current = state.typeMode || TYPE_KEYS.TYPE_A;
          document.querySelectorAll('[data-type-option]').forEach(function(btn){
            btn.classList.toggle('active', btn.dataset.typeOption === current);
          });
        }

        function showTypeSelection(){
          const typeCard = $('typeCard');
          const loginCard = $('loginCard');
          if (typeCard) typeCard.style.display = 'block';
          if (loginCard) loginCard.style.display = 'none';
          highlightTypeButtons();
        }

        function showLoginCard(){
          const typeCard = $('typeCard');
          const loginCard = $('loginCard');
          if (typeCard) typeCard.style.display = 'none';
          if (loginCard) {
            loginCard.style.display = 'block';
            const studentIdInput = $('studentIdInput');
            if (studentIdInput) studentIdInput.focus();
          }
        }

        function setText(id, text){
          const el = $(id);
          if (!el) return;
          el.textContent = text || '';
        }

        function init(){
          const loginForm = $('loginForm');
          if (loginForm) loginForm.addEventListener('submit', onLoginSubmit);
          const restartBtn = $('btnRestart');
          if (restartBtn) restartBtn.addEventListener('click', function(){
            if (state.sessionKey && !confirm('현재 세션을 종료하고 처음 화면으로 돌아가시겠습니까?')) return;
            resetToTypeSelection(true, DEFAULT_TYPE);
          });

          document.querySelectorAll('[data-type-option]').forEach(function(btn){
            btn.addEventListener('click', function(){
              const typeKey = btn.dataset.typeOption;
              if (!typeKey) return;
              resetState({ typeMode: typeKey });
              setTypeMode(typeKey, { skipWorkspace: true });
              buildStepIndicator();
              renderWorkspace();
              showLoginCard();
              setStatus(`${getTypeConfig(typeKey).label || 'Type'}을 선택했습니다. 식별 번호와 이름을 입력하세요.`, 'info');
            });
          });

          const changeTypeBtn = $('btnChangeType');
          if (changeTypeBtn) changeTypeBtn.addEventListener('click', function(){
            if (state.sessionKey && !confirm('현재 진행 중인 세션이 종료됩니다. 계속할까요?')) return;
            resetToTypeSelection(true, state.typeMode || DEFAULT_TYPE);
          });

          const prewritingInput = $('prewritingInput');
          if (prewritingInput) prewritingInput.addEventListener('input', function(){
            const btn = $('btnPreSubmit');
            if (!btn) return;
            const isStageActive = Number(state.stage || 1) === 1;
            btn.disabled = !isStageActive || !this.value.trim();
            state.localPrewritingDraft = this.value;
          });

          const draftInput = $('draftInput');
          if (draftInput) draftInput.addEventListener('input', function(){
            const btn = $('btnSaveDraft');
            if (!btn) return;
            const stage = Number(state.stage || 1);
            const editable = stage === 2 && !state.writing.final.submittedAt;
            state.localDraftBuffer = this.value;
            btn.disabled = !editable || !this.value.trim();
          });

          const draftBackBtn = $('btnDraftBack');
          if (draftBackBtn) draftBackBtn.addEventListener('click', onGoToPreviousStage);

          const notesInput = $('notesInput');
          if (notesInput) notesInput.addEventListener('input', function(){
            const btn = $('btnNotesSave');
            if (!btn) return;
            const stage = Number(state.stage || 1);
            const group = (state.group || '').toUpperCase();
            const enabled = (stage === 3 && (group === 'A' || group === 'B')) && !state.writing.final.submittedAt;
            state.localStage3Memo = this.value;
            btn.disabled = !enabled || !this.value.trim();
          });

          const stage3BackBtn = $('btnStage3Back');
          if (stage3BackBtn) stage3BackBtn.addEventListener('click', onGoToPreviousStage);

          const finalInput = $('finalInput');
          if (finalInput) finalInput.addEventListener('input', function(){
            state.localFinalDraft = this.value;
            const btn = $('btnFinalSubmit');
            if (!btn) return;
            const canEdit = Number(state.stage || 1) === 4 && !(state.writing.final && Number(state.writing.final.submittedAt || 0) > 0);
            btn.disabled = !canEdit || !this.value.trim();
          });

          const finalBackBtn = $('btnFinalBack');
          if (finalBackBtn) finalBackBtn.addEventListener('click', onGoToPreviousStage);

          const dictQuery = $('dictQuery');
          if (dictQuery) dictQuery.addEventListener('keydown', function(e){ if (e.key === 'Enter'){ e.preventDefault(); onDictionarySearch(); } });
          const dictBtn = $('btnDictSearch');
          if (dictBtn) dictBtn.addEventListener('click', onDictionarySearch);

          const aiSendBtn = $('btnAiSend');
          if (aiSendBtn) aiSendBtn.addEventListener('click', sendAiMessage);
          const aiInput = $('aiInput');
          if (aiInput) aiInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendAiMessage(); } });

          const peerSendBtn = $('btnPeerSend');
          if (peerSendBtn) peerSendBtn.addEventListener('click', sendPeerMessage);
          const peerInput = $('peerInput');
          if (peerInput) peerInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendPeerMessage(); } });

          const stage5MemoInput = $('stage5MemoInput');
          if (stage5MemoInput) stage5MemoInput.addEventListener('input', function(){
            const btn = $('btnStage5MemoSave');
            if (!btn) return;
            btn.disabled = !this.value.trim();
          });
          const stage5MemoSave = $('btnStage5MemoSave');
          if (stage5MemoSave) stage5MemoSave.addEventListener('click', onSaveStage5Memo);

          const preBtn = $('btnPreSubmit');
          if (preBtn) preBtn.addEventListener('click', onSubmitPrewriting);
          const draftSaveBtn = $('btnSaveDraft');
          if (draftSaveBtn) draftSaveBtn.addEventListener('click', onSaveDraft);
          const toPeerBtn = $('btnToPeer');
          if (toPeerBtn) toPeerBtn.addEventListener('click', onAdvanceToPeerStage);
          const notesSaveBtn = $('btnNotesSave');
          if (notesSaveBtn) notesSaveBtn.addEventListener('click', onSavePeerNotes);
          const finalBtn = $('btnFinalSubmit');
          if (finalBtn) finalBtn.addEventListener('click', onSubmitFinalWriting);
          const peerNextBtn = $('btnPeerNext');
          if (peerNextBtn) peerNextBtn.addEventListener('click', onPeerNextStage);

          highlightTypeButtons();
          showTypeSelection();

          loadPublicSettings();
          buildStepIndicator();
          renderWorkspace();
          updateSelectedTypeLabel();
          setStatus('Type을 선택한 뒤 식별 번호와 이름을 입력하세요.', 'info');

          if (hasGas) {
            try {
        google.script.run.withSuccessHandler(function(info){
                if (!info) return;
                if (!info.teacherSheetId) {
                  $('loginMessage').textContent = '⚠️ 관리자: 교사 시트 ID가 설정되지 않았습니다.';
                }
        }).getServerDiag();
            } catch (e) { console.error(e); }
          }

          window.addEventListener('beforeunload', function(){
            if (!hasGas) return;
            try {
              if (state.sessionKey && state.user.id) {
                google.script.run.postPresenceLeave(state.sessionKey, state.user.id, state.user.name);
              }
            } catch (e) { console.error(e); }
          });
        }

        function resetState(options){
          const opts = options || {};
          if (opts.typeMode) {
            state.typeMode = opts.typeMode;
          }
          const config = getTypeConfig(state.typeMode);
          state.group = config.group;
          state.sessionKey = '';
          state.user = { id: '', name: '' };
          state.stage = 1;
          state.updatedAt = 0;
          state.stageChangePending = false;
          state.writing = {
            prewriting: { text: '', submittedAt: 0 },
            draft: { text: '', savedAt: 0 },
            notes: { text: '', updatedAt: 0 },
            final: { text: '', submittedAt: 0 }
          };
          state.steps = {};
          state.partner = null;
          state.presence = null;
          state.status = { message: '식별 번호와 이름을 입력하면 세션이 시작됩니다.', type: 'info' };
          state.aiChat = { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false, awaitingResponse: false, welcomeShown: false };
          state.peerChat = { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false };
          state.dictionaryHistory = [];
          state.refreshingState = false;
          clearChatLog('ai');
          clearChatLog('peer');
          state.localPrewritingDraft = '';
          state.localFinalDraft = '';
          state.localDraftBuffer = '';
          state.localStage3Memo = '';
          state.localStage5Memo = '';
          state.aiStageLogs = {};
          state.aiTranscriptKeys = {};
          state.currentAiStage = 0;
          state.aiAvatarUrl = publicConfig.aiAvatarUrl || DEFAULT_AI_AVATAR;
        }

        function resetToTypeSelection(clearInput, nextType){
          clearAllTimers();
          if (nextType) {
            resetState({ typeMode: nextType });
          } else {
            resetState();
          }
          $('workspace').style.display = 'none';
          showTypeSelection();
          if (clearInput) {
            $('studentIdInput').value = '';
            $('studentNameInput').value = '';
          }
          buildStepIndicator();
          updateSelectedTypeLabel();
          renderUserInfo();
          setStatus('Type을 선택한 뒤 식별 번호와 이름을 입력하세요.', 'info');
        }

        function onLoginSubmit(e){
          e.preventDefault();
          if (!hasGas) {
            handleError('백엔드 서비스가 연결되지 않았습니다.');
            return;
          }
          const sid = $('studentIdInput').value.trim();
          const name = $('studentNameInput').value.trim();
          if (!sid || !name) { setStatus('식별 번호와 이름을 모두 입력하세요.', 'warn'); return; }
          $('loginSubmit').disabled = true;
          $('loginSubmit').textContent = '진행 중...';
          setStatus('세션을 초기화하는 중입니다...', 'info');
        google.script.run.withSuccessHandler(function(res){
            $('loginSubmit').disabled = false;
            $('loginSubmit').textContent = '실험 시작';
            onSessionStart(res);
            setStatus('세션이 시작되었습니다. 1단계를 진행하세요.', 'success');
          }).withFailureHandler(function(err){
            $('loginSubmit').disabled = false;
            $('loginSubmit').textContent = '실험 시작';
            handleError(err);
          }).startSession(state.group, sid, name);
        }

        function onSessionStart(res){
          if (!res) { handleError('세션 정보를 불러오지 못했습니다.'); return; }
          const resolvedGroup = (res.mode || res.group || state.group || getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A).group || 'A').toUpperCase();
          const resolvedType = mapGroupToTypeKey(resolvedGroup);
          setTypeMode(resolvedType, { skipWorkspace: true });
          state.group = resolvedGroup;
          state.user = { id: (res.you && res.you.id) || '', name: (res.you && res.you.name) || '' };
          state.sessionKey = res.sessionKey || '';
          state.aiChat = { sessionId: res.aiSessionId || '', lastTs: 0, rendered: {}, pending: {}, fetching: false, awaitingResponse: false, welcomeShown: false };
          state.peerChat = { sessionId: res.peerSessionId || '', lastTs: 0, rendered: {}, pending: {}, fetching: false };
          state.aiAvatarUrl = publicConfig.aiAvatarUrl || state.aiAvatarUrl || DEFAULT_AI_AVATAR;
          state.localPrewritingDraft = '';
          state.stageChangePending = false;
          updateSelectedTypeLabel();
          $('loginCard').style.display = 'none';
          $('workspace').style.display = 'flex';
          const sessionState = {
            sessionKey: res.sessionKey,
            stage: res.stage,
            updatedAt: Number(res.updatedAt || 0),
            prewriting: res.writing && res.writing.prewriting ? res.writing.prewriting : res.prewriting,
            draft: res.writing && res.writing.draft ? res.writing.draft : res.draft,
            notes: res.writing && res.writing.notes ? res.writing.notes : res.notes,
            final: res.writing && res.writing.final ? res.writing.final : res.final,
            steps: res.steps,
            partner: res.partner,
            presence: res.presence,
            aiSessionId: res.aiSessionId,
            peerSessionId: res.peerSessionId
          };
          syncSessionState(sessionState);
          ensurePollers();
          sendPresencePing();
          pollAiMessages();
          pollPeerMessages();
        }

        function syncSessionState(data){
          if (!data) return;
          const currentUpdatedAt = Number(state.updatedAt || 0);
          const incomingUpdatedAt = Number(data.updatedAt || 0);
          if (incomingUpdatedAt && currentUpdatedAt && incomingUpdatedAt < currentUpdatedAt) {
            console.warn('Stale session state ignored', data);
            return;
          }
          if (incomingUpdatedAt) {
            state.updatedAt = incomingUpdatedAt;
          }
          const prevStage = Number(state.stage || 1);
          if (data.sessionKey) state.sessionKey = data.sessionKey;
          if (data.aiSessionId) {
            const prevAiSessionId = state.aiChat.sessionId;
            state.aiChat.sessionId = data.aiSessionId;
            if (prevAiSessionId && prevAiSessionId !== data.aiSessionId) {
              clearChatLog('ai');
              state.aiChat.welcomeShown = false;
            }
          }
          const prevPeerSessionId = state.peerChat.sessionId;
          if (data.peerSessionId !== undefined && data.peerSessionId !== null) {
            state.peerChat.sessionId = String(data.peerSessionId).trim();
          }
          if (prevPeerSessionId && state.peerChat.sessionId && prevPeerSessionId !== state.peerChat.sessionId) {
            clearChatLog('peer');
            state.peerChat.lastTs = 0;
          }
          var incomingStage = Number(data.stage || 0);
          if (incomingStage) {
            state.stage = incomingStage;
          }
          if (!state.stage || state.stage < 1) state.stage = 1;
          const incomingWriting = data.writing || {};
          state.writing.prewriting = incomingWriting.prewriting || data.prewriting || state.writing.prewriting;
          state.writing.draft = incomingWriting.draft || data.draft || state.writing.draft;
          state.writing.notes = incomingWriting.notes || data.notes || state.writing.notes;
          state.writing.final = incomingWriting.final || data.final || state.writing.final;
          if (Number(state.stage || 1) <= 1 && !(state.writing.prewriting && Number(state.writing.prewriting.submittedAt || 0))) {
            if (typeof state.localPrewritingDraft !== 'string' || !state.localPrewritingDraft) {
              state.localPrewritingDraft = (state.writing.prewriting && state.writing.prewriting.text) || state.localPrewritingDraft || '';
            }
          } else {
            state.localPrewritingDraft = '';
          }
          state.steps = data.steps || state.steps;
          state.partner = data.partner || null;
          state.presence = data.presence || null;

          const currentStage = Number(state.stage || 1);
          if (currentStage === 4) {
            if (state.writing.final && Number(state.writing.final.submittedAt || 0) > 0) {
              state.localFinalDraft = state.writing.final.text || '';
            } else if (prevStage !== 4 && !state.localFinalDraft) {
              state.localFinalDraft = (state.writing.final && state.writing.final.text) || (state.writing.prewriting && state.writing.prewriting.text) || '';
            }
          } else if (currentStage < 4) {
            state.localFinalDraft = '';
          }

          const group = (state.group || '').toUpperCase();
          if (state.writing.draft && state.writing.draft.text) {
            if (currentStage !== 2 || !state.localDraftBuffer || state.localDraftBuffer === state.writing.draft.text) {
              state.localDraftBuffer = state.writing.draft.text;
            }
          } else if (currentStage !== 2) {
            state.localDraftBuffer = '';
          }

          if (state.writing.notes && state.writing.notes.text) {
            if (currentStage !== 3 || !state.localStage3Memo || state.localStage3Memo === state.writing.notes.text) {
              state.localStage3Memo = state.writing.notes.text;
            }
          } else if (currentStage !== 3) {
            state.localStage3Memo = '';
          }

          renderWorkspace();
          ensurePollers();
        }

        function applyStageLabelsToPanels(){
          const combine = (label, fallback) => {
            if (!label) return fallback;
            if (label.headline) return `${label.name} · ${label.headline}`;
            return label.name || fallback;
          };
          const stage1 = getStageLabel(1);
          if (stage1) {
            setText('promptStageTitle', combine(stage1, '2차시 · 토론 관련 발문'));
            setText('promptStageSubtitle', stage1.description || '논제 이해를 위해 핵심 발문을 확인하세요.');
            setText('prewritingTitle', combine(stage1, '2차시 · 메모장'));
            setText('prewritingInfo', stage1.description || '인터넷 검색으로 찬성·반대 근거를 수집하며 메모를 남기세요.');
            setText('aiStageTitle', stage1.headline || stage1.name || 'AI 피드백');
            setText('aiStageSubtitle', stage1.description || 'AI와 토론 연습을 진행하세요.');
          }
          const stage2 = getStageLabel(2);
          if (stage2) {
            setText('draftTitle', combine(stage2, '3-1차시 · 토론 메모'));
            setText('draftInfo', stage2.description || 'ChatGPT와 모의 토론 중 떠오른 생각을 정리하세요.');
            const transcriptHeading = $('stage3TranscriptHeading');
            if (transcriptHeading) {
              transcriptHeading.textContent = (stage2.name || '3-1차시') + ' 토론 기록';
            }
          }
          const stage3 = getStageLabel(3);
          if (stage3) {
            setText('memoStage3Title', combine(stage3, '3-2차시 · 동료 토론 메모'));
            setText('memoStage3Info', stage3.description || '동료에게 받은 피드백을 메모하세요.');
            setText('peerStageTitle', stage3.headline || stage3.name || '동료 피드백');
            setText('peerStageSubtitle', stage3.description || '동료와 상호작용하며 피드백을 주고받으세요.');
            const memoInfoEl = $('memoStage3Info');
            if (memoInfoEl) memoInfoEl.dataset.baseText = memoInfoEl.textContent || '';
          }
          const stage4 = getStageLabel(4);
          if (stage4) {
            setText('stage4Title', combine(stage4, '4차시 · 토론 발문'));
            setText('stage4Subtitle', stage4.description || '관리자가 입력한 발문을 확인하세요.');
            setText('finalStageTitle', combine(stage4, 'ChatGPT와 토론 (gpt-4.1-mini)'));
            setText('finalStageSubtitle', stage4.description || '관리자 시스템 프롬프트를 기반으로 토론을 진행합니다.');
          }
          const stage5 = getStageLabel(5);
          if (stage5) {
            setText('stage5Title', combine(stage5, '5차시 · 정리'));
            setText('stage5Subtitle', stage5.description || '4-1차시 대화를 요약해 확인하고, 추가로 메모하세요.');
          }
        }

        function renderWorkspace(){
          applyStageLabelsToPanels();
          renderUserInfo();
          updateStepIndicator();
          updateStageVisibility();
          renderPrewritingPanel();
          renderDraftPanel();
          renderPeerPanel();
          renderStagePrompts();
          renderFinalPanel();
          renderStage5Panel();
        renderFinalChatPanel();
          renderRightPanels();
          renderPartnerPanel();
          renderPresence();
          renderDictionaryHistory();
          refreshChatControls();

          // AI/peer 채팅은 단계 전환 시 초기화
          const numericStage = Number(state.stage || 1);
          const aiStageActive = isAiChatStage(numericStage);
          if (!aiStageActive) {
            if (state.currentAiStage) {
              clearChatLog('ai', { keepLastTs: false });
              state.aiChat.welcomeShown = false;
            }
            state.currentAiStage = 0;
          } else if (state.currentAiStage !== numericStage) {
            clearChatLog('ai', { keepLastTs: true });
            state.aiChat.welcomeShown = false;
            state.currentAiStage = numericStage;
          }
          const peerStageActive = isPeerChatStage(numericStage);
          if (!peerStageActive) {
            clearChatLog('peer');
          }
        }

        function getPreviousStageNumber(){
          const current = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          if (current <= 1) return 1;
          if (current === 2) return 1;
          if (current === 3) return 2;
          if (current === 4) return group === 'C' ? 2 : 3;
          if (current >= 5) return 4;
          return Math.max(1, current - 1);
        }

        function updateStageVisibility(){
          const stage = Number(state.stage || 1);
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const showStage1 = stage <= 1;
          const showStage2 = stage === 2;
          const showStage3 = stage === 3;
          const showStage4 = stage === 4;
          const showStage5 = stage >= 5;
          setPanelVisibility('panelPrompt', stage === 1);
          setPanelVisibility('panelPrewriting', showStage1 && typeKey === TYPE_KEYS.TYPE_A);
          setPanelVisibility('panelDraft', showStage2);
          setPanelVisibility('panelMemoStage3', showStage3);
          setPanelVisibility('panelFinalSummary', showStage4);
          setPanelVisibility('panelStage5', showStage5);
        }

        function setPanelVisibility(id, visible){
          var el = $(id);
          if (!el) return;
          el.style.display = visible ? 'flex' : 'none';
        }

        function buildStepIndicator(){
          const container = $('stepIndicator');
          if (!container) return;
          container.innerHTML = '';
          const typeConfig = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const labels = getStageLabelsForType(state.typeMode || TYPE_KEYS.TYPE_A);
          const template = Array.isArray(typeConfig.stepTemplate) ? typeConfig.stepTemplate : [];
          template.forEach(function(entry){
            const item = document.createElement('div');
            item.className = 'step-item';
            item.dataset.step = entry.stage;
            if (entry.segment) item.dataset.segment = entry.segment;
            item.dataset.titleOverride = entry.titleOverride || '';
            const number = document.createElement('div');
            number.className = 'step-number';
            number.textContent = entry.badge || entry.stage;
            const info = document.createElement('div');
            info.className = 'step-info';
            const title = document.createElement('div');
            title.className = 'step-title';
            const labelIndex = Math.max(0, Math.min(labels.length - 1, Number(entry.stage || 1) - 1));
            const label = labels[labelIndex] || {};
            title.textContent = entry.titleOverride || label.name || `단계 ${entry.stage}`;
            const caption = document.createElement('div');
            caption.className = 'step-caption';
            caption.textContent = label.headline || label.description || '';
            info.appendChild(title);
            info.appendChild(caption);
            item.appendChild(number);
            item.appendChild(info);
            item.addEventListener('click', onStepIndicatorClick);
            container.appendChild(item);
          });
          updateStepIndicator();
        }

        function renderUserInfo(){
          const el = $('userInfo');
          if (!el) return;
          const config = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const typeLabel = config.label || 'Type A';
          if (state.sessionKey) {
            const userLabel = `${state.user.id || ''} ${state.user.name || ''}`.trim();
            el.textContent = userLabel ? `${typeLabel} · ${userLabel}` : typeLabel;
          } else {
            el.textContent = typeLabel;
          }
        }

        function updateStepIndicator(){
          const current = Number(state.stage || 1);
          document.querySelectorAll('#stepIndicator .step-item').forEach(function(item){
            const step = Number(item.dataset.step);
            item.classList.toggle('active', step === current);
            item.classList.toggle('completed', step < current);
            const canNavigate = step !== current && canSelectStage(step) && !state.stageChangePending && !state.sessionKey;
            item.classList.toggle('clickable', canNavigate);
            item.setAttribute('aria-disabled', canNavigate ? 'false' : 'true');
            item.style.cursor = canNavigate ? 'pointer' : '';
            const titleNode = item.querySelector('.step-title');
            const captionNode = item.querySelector('.step-caption');
            const label = getStageLabel(step);
            if (titleNode) {
              const override = item.dataset.titleOverride;
              titleNode.textContent = override || label?.name || `단계 ${step}`;
            }
            if (captionNode) {
              captionNode.textContent = label?.headline || label?.description || '';
            }
          });
        }

        function getHighestUnlockedStage(){
          let highest = Number(state.stage || 1) || 1;
          const steps = state.steps || {};
          
          // 1단계(사전 글쓰기)가 완료되면 이후 단계(2,3,4)를 모두 자유롭게 이동할 수 있도록 허용
          if (steps.prewriting && steps.prewriting.completed) {
            return 5;
          }
          
          const group = (state.group || '').toUpperCase();
          if (steps.prewriting && steps.prewriting.completed) {
            highest = Math.max(highest, 2);
          }
          if (group === 'A' || group === 'B') {
            if (steps.draft && steps.draft.saved) {
              highest = Math.max(highest, 3);
            }
            const finalUnlocked = Number(state.stage || 1) >= 4 || (state.writing && state.writing.final && (state.writing.final.text || Number(state.writing.final.submittedAt || 0))) || (steps.final && steps.final.submitted);
            if (finalUnlocked) {
              highest = Math.max(highest, 4);
            }
          } else if (group === 'C') {
            const finalUnlocked = Number(state.stage || 1) >= 4 || (state.writing && state.writing.final && (state.writing.final.text || Number(state.writing.final.submittedAt || 0))) || (steps.final && steps.final.submitted);
            if (finalUnlocked) {
              highest = Math.max(highest, 4);
            }
          } else {
            if (Number(state.stage || 1) >= 4 || (steps.final && steps.final.submitted)) {
              highest = Math.max(highest, 4);
            }
          }
          if (Number(state.stage || 1) >= 5) {
            highest = Math.max(highest, 5);
          }
          return Math.max(1, Number(highest || 1));
        }

        function canSelectStage(step){
          const desired = Number(step || 0);
          if (!desired || desired < 1) return false;
          if (desired === 1) return false;
          const group = (state.group || '').toUpperCase();
          if (desired === 3 && !(group === 'A' || group === 'B')) return false;
          const highest = getHighestUnlockedStage();
          return desired <= highest;
        }

        function navigateToStage(targetStage){
          const target = Number(targetStage || 0);
          if (!target || target < 1) return;
          const current = Number(state.stage || 1);
          if (target === current) return;
          const highest = getHighestUnlockedStage();
          if (target > highest) {
            setStatus('아직 진행되지 않은 단계입니다.', 'warn');
            return;
          }
          if (!canSelectStage(target)) {
            setStatus('해당 단계로 이동할 수 없습니다.', 'warn');
            return;
          }
          if (!hasGas) return;
          if (!state.sessionKey) { setStatus('세션이 활성화되지 않았습니다.', 'error'); return; }
          if (state.stageChangePending) return;
          state.stageChangePending = true;
          updateStepIndicator();
          const label = formatStageName(target) || (target + '단계');
          setStatus(label + '로 이동하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            state.stageChangePending = false;
            if (res && typeof res.stage !== 'undefined') {
              syncSessionState(res);
              setStatus(formatStageName(res.stage) + '로 이동했습니다.', 'success');
            } else {
              syncSessionState(res || {});
              setStatus('단계를 변경했습니다.', 'success');
            }
          }).withFailureHandler(function(err){
            state.stageChangePending = false;
            updateStepIndicator();
            handleError(err);
          }).jumpToStage(state.sessionKey, target);
        }

        function onStepIndicatorClick(event){
          const step = Number(event.currentTarget && event.currentTarget.dataset.step);
          if (!step) return;
          navigateToStage(step);
        }

        function renderPrewritingPanel(){
          const textarea = $('prewritingInput');
          const readonly = $('prewritingReadonly');
          const info = $('prewritingInfo');
          if (!textarea || !readonly || !info) return;
          const storedText = state.writing.prewriting.text || '';
          const submittedAt = Number(state.writing.prewriting.submittedAt || 0);
          const isStageActive = Number(state.stage || 1) === 1;
          const completed = Boolean(storedText && submittedAt);
          if (!completed && !state.localPrewritingDraft) {
            state.localPrewritingDraft = storedText;
          }
          const workingText = completed ? storedText : (typeof state.localPrewritingDraft === 'string' ? state.localPrewritingDraft : storedText);
          textarea.value = workingText;
          if (!completed && isStageActive) {
            state.localPrewritingDraft = workingText;
          }
          textarea.disabled = completed || !isStageActive;
          readonly.style.display = completed ? 'block' : 'none';
          readonly.textContent = completed ? storedText : '';
          const submitBtn = $('btnPreSubmit');
          if (submitBtn) submitBtn.disabled = !isStageActive || completed || !textarea.value.trim();
          info.textContent = completed ? '제출 시간: ' + formatDate(submittedAt) : '사전 글쓰기를 작성하고 제출하세요.';
        }

        function renderDraftPanel(){
          const textarea = $('draftInput');
          const info = $('draftInfo');
          const titleEl = $('draftTitle');
          const previewEl = $('prewritingPreview');
          if (!textarea || !info) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const editable = stage === 2 && !state.writing.final.submittedAt;
          const savedText = state.writing.draft.text || '';
          if (previewEl) {
            const prewritingText = (state.writing.prewriting && state.writing.prewriting.text) || '';
            previewEl.textContent = prewritingText ? prewritingText : '2차시 메모가 아직 저장되지 않았습니다.';
          }
          if (savedText) {
            state.localDraftBuffer = savedText;
          }
          const workingText = stage === 2 ? (state.localDraftBuffer || savedText || '') : savedText;
          if (textarea.value !== workingText) textarea.value = workingText;
          textarea.disabled = !editable;
          if (editable) state.localDraftBuffer = textarea.value;
          const saveBtn = $('btnSaveDraft');
          if (saveBtn) saveBtn.disabled = !editable || !textarea.value.trim();
          const moveBtn = $('btnToPeer');
          if (moveBtn) {
            const hasSaved = !!savedText && Number(state.writing.draft.savedAt || 0) > 0;
            let nextLabel = '다음 단계로 이동';
            if (group === 'A') nextLabel = '동료 피드백 단계로 이동';
            else if (group === 'C') nextLabel = '최종 단계로 이동';
            else if (group === 'B') nextLabel = 'AI 피드백 단계로 이동';
            moveBtn.textContent = nextLabel;
            moveBtn.disabled = !hasSaved;
          }
          if (titleEl) {
            if (group === 'B') titleEl.textContent = '2단계 · 동료 메모';
            else titleEl.textContent = '2단계 · 글쓰기 수정 관련 메모';
          }
          const savedAt = Number(state.writing.draft.savedAt || 0);
          if (savedAt) {
            info.textContent = '마지막 메모 저장: ' + formatDate(savedAt);
        } else {
            if (group === 'B') {
              info.textContent = '동료와의 대화에서 얻은 포인트를 기록한 뒤 이동하세요.';
            } else {
              info.textContent = 'AI 튜터에게 받은 피드백을 참고하여, 글을 어떻게 수정할지에 대한 아이디어를 메모 형태로 자유롭게 정리하세요.';
            }
          }
          const backBtn = $('btnDraftBack');
          if (backBtn) {
            const prevStage = getPreviousStageNumber();
            const currentStage = Number(state.stage || 1);
            if (prevStage < currentStage) {
              backBtn.disabled = false;
              backBtn.textContent = '← ' + (formatStageName(prevStage) || (prevStage + '단계')) + '로 이동';
            } else {
              backBtn.disabled = true;
              backBtn.textContent = '이전 단계로 이동';
            }
          }
        }

        function renderPeerPanel(){
          const stage = Number(state.stage || 1);
          const isMemoStage = stage === 3;
          const currentLabel = getStageLabel(stage) || {};
          const titleEl = $('memoStage3Title');
          const infoEl = $('memoStage3Info');
          const notesInput = $('notesInput');
          const saveBtn = $('btnNotesSave');
          const nextBtn = $('btnPeerNext');
          if (!notesInput || !saveBtn || !nextBtn) return;

          if (titleEl) {
            const combined = currentLabel.headline ? `${currentLabel.name || ''} · ${currentLabel.headline}` : (currentLabel.name || '동료 메모');
            titleEl.textContent = combined;
          }

          if (infoEl) {
            if (!infoEl.dataset.baseText) {
              infoEl.dataset.baseText = infoEl.textContent || currentLabel.description || '';
            }
            let base = infoEl.dataset.baseText || currentLabel.description || infoEl.textContent || '';
            const memoSavedAt = Number(state.writing.notes.updatedAt || 0);
            if (memoSavedAt) {
              base += ' · 마지막 저장: ' + formatDate(memoSavedAt);
            }
            infoEl.textContent = base;
          }

          const transcriptBlock = document.querySelector('.stage3-transcript-block');
          if (transcriptBlock) transcriptBlock.style.display = stage === 3 ? 'block' : 'none';

          if (state.writing.notes && state.writing.notes.text) {
            if (!isMemoStage || !state.localStage3Memo || state.localStage3Memo === state.writing.notes.text) {
              state.localStage3Memo = state.writing.notes.text;
            }
          } else if (stage !== 3) {
            state.localStage3Memo = '';
          }

          const workingText = isMemoStage ? (state.localStage3Memo || state.writing.notes.text || '') : (state.writing.notes.text || '');
          if (notesInput.value !== workingText) notesInput.value = workingText;

          const memoEnabled = isMemoStage && !state.writing.final.submittedAt;
          notesInput.disabled = !memoEnabled;
          if (memoEnabled) state.localStage3Memo = notesInput.value;
          saveBtn.disabled = !memoEnabled || !notesInput.value.trim();

          nextBtn.textContent = '최종 단계로 이동';
          const hasSaved = !!(state.writing.notes.text && state.writing.notes.updatedAt);
          nextBtn.disabled = !isMemoStage || !hasSaved;

          renderStage3Transcript();

          const backBtn = $('btnStage3Back');
          if (backBtn) {
            const prevStage = getPreviousStageNumber();
            const currentStage = Number(state.stage || 1);
            if (prevStage < currentStage) {
              backBtn.disabled = false;
              backBtn.textContent = '← ' + (formatStageName(prevStage) || (prevStage + '단계')) + '로 이동';
            } else {
              backBtn.disabled = true;
              backBtn.textContent = '이전 단계로 이동';
            }
          }
        }

        function renderFinalPanel(){
          // 4차시는 발문/챗봇 중심 UI로 전환되어 최종 글쓰기 패널 사용 안 함
        }

        function renderStagePrompts(){
          const stage1Prompt = getStagePromptData(1);
          setRichText(
            'promptContent',
            stage1Prompt.reference || publicConfig.promptContent,
            '토론 발문이 아직 등록되지 않았습니다.'
          );
          const stage2Prompt = getStagePromptData(2);
          setRichText(
            'draftPromptContent',
            stage2Prompt.reference || stage1Prompt.reference || publicConfig.promptContent,
            '관리자가 등록한 발문이 여기에 표시됩니다.'
          );
          const stage3Prompt = getStagePromptData(3);
          setRichText(
            'stage3MemoHelper',
            stage3Prompt.reference || '먼저 3-1차시 기록을 읽고, 보완하고 싶은 근거·질문을 메모하세요.',
            '먼저 3-1차시 기록을 읽고, 보완하고 싶은 근거·질문을 메모하세요.'
          );
          const stage4Prompt = getStagePromptData(4);
          setRichText(
            'stage4PromptContent',
            stage4Prompt.reference || publicConfig.promptContent,
            '관리자가 등록한 발문이 여기에 표시됩니다.'
          );
          const stage5Prompt = getStagePromptData(5);
          setRichText(
            'stage5TranscriptSummary',
            stage5Prompt.reference || '4-1 토론 기록을 불러오는 중입니다. (추후 연동)',
            '4-1 토론 기록을 불러오는 중입니다. (추후 연동)'
          );
        }

        function recordAiTranscript(message, ts){
          if (!message) return;
          const stage =
            Number(message?.ext?.stage) ||
            Number(message?.stage) ||
            Number(message?.metadata?.stage) ||
            0;
          if (!stage) return;
          const key =
            stage +
            ':' +
            (message.role || 'user') +
            ':' +
            (message.senderId || '') +
            ':' +
            (ts || message.ts || 0) +
            ':' +
            (message.text || '').slice(0, 120);
          if (state.aiTranscriptKeys[key]) return;
          state.aiTranscriptKeys[key] = true;
          if (!state.aiStageLogs[stage]) state.aiStageLogs[stage] = [];
          state.aiStageLogs[stage].push({
            stage,
            ts: ts || message.ts || Date.now(),
            role: message.role || 'user',
            sender: message.senderName || (message.role === 'ai' ? 'AI' : state.user.name || '학생'),
            text: message.text || '',
          });
          if (state.aiStageLogs[stage].length > 150) {
            state.aiStageLogs[stage] = state.aiStageLogs[stage].slice(-150);
          }
          if (stage === 2 && Number(state.stage || 1) >= 3) {
            renderStage3Transcript();
          }
        }

        function renderStage3Transcript(){
          const container = $('stage3Transcript');
          if (!container) return;
          const logs = (state.aiStageLogs[2] || []).slice(-12);
          if (!logs.length) {
            container.innerHTML =
              '<div class="stage3-transcript-line">3-1차시 토론 기록이 아직 없습니다.</div>';
            return;
          }
          const html = logs
            .map(function(entry){
              const label = entry.role === 'ai' ? 'AI 응답' : '나의 질문';
              const text = escapeHtml(entry.text || '').replace(/\n/g, '<br/>');
              return `<div class="stage3-transcript-line ${entry.role === 'ai' ? 'ai' : 'me'}"><span class="label">${label}</span>${text}</div>`;
            })
            .join('');
          container.innerHTML = html;
        }

        function renderStage5Panel(){
          const memoInput = $('stage5MemoInput');
          const saveBtn = $('btnStage5MemoSave');
          const stage = Number(state.stage || 1);
          const enabled = stage >= 5;
          const memoText = state.localStage5Memo || '';
          if (memoInput) {
            memoInput.value = memoText;
            memoInput.disabled = !enabled;
          }
          if (saveBtn) {
            saveBtn.disabled = !enabled || !memoText.trim();
          }
        }

        function renderFinalChatPanel(){
          const logEl = $('finalChatLog');
          const inputEl = $('finalChatInput');
          const sendBtn = $('btnFinalChatSend');
          const stage = Number(state.stage || 1);
          const aiEnabled = !!state.aiChat.sessionId && stage >= 4;
          if (logEl) {
            logEl.innerHTML = '';
            // reuse existing ai chat log data: render last known messages for ai channel
            const messages = Object.keys(state.aiChat.rendered || {}).length
              ? []
              : [];
            // 단순 초기화만 수행 (기존 채팅 렌더는 pollAiMessages에서 처리)
          }
          if (inputEl) inputEl.disabled = !aiEnabled || (state.aiChat && state.aiChat.awaitingResponse);
          if (sendBtn) sendBtn.disabled = !aiEnabled || (state.aiChat && state.aiChat.awaitingResponse);
        }

        function onSaveStage5Memo(){
          const memoInput = $('stage5MemoInput');
          if (!memoInput) return;
          const text = memoInput.value.trim();
          if (!text) { setStatus('5차시 메모를 입력하세요.', 'warn'); return; }
          state.localStage5Memo = text;
          const btn = $('btnStage5MemoSave');
          if (btn) btn.disabled = true;
          setStatus('5차시 메모가 로컬에 저장되었습니다. (서버 연동 필요)', 'success');
        }

        function isAiChatStage(stage){
          const config = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const list = Array.isArray(config.aiStages) ? config.aiStages : [];
          return list.includes(Number(stage || 0));
        }

        function isPeerChatStage(stage){
          const config = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const list = Array.isArray(config.peerStages) ? config.peerStages : [];
          return list.includes(Number(stage || 0));
        }

        function renderRightPanels(){
          const stage = Number(state.stage || 1);
          const showAiChat = isAiChatStage(stage);
          const showPeerChat = isPeerChatStage(stage);
          const showFinalChat = stage >= 4;
          if (showAiChat) updateAiPanelHeader(stage);
          if (showPeerChat) updatePeerPanelHeader(stage);
          togglePanel('rightStage2', showAiChat);
          togglePanel('rightStage3', showPeerChat);
          togglePanel('rightStage4', showFinalChat);
          if (showAiChat || showFinalChat) ensureAiWelcomeMessage();
        }

        function updateAiPanelHeader(stage){
          const label = getStageLabel(stage);
          if (!label) return;
          const combined = label.headline ? `${label.name} · ${label.headline}` : label.name;
          setText('aiStageTitle', combined || 'AI 토론');
          setText('aiStageSubtitle', label.description || 'AI와 토론을 이어가며 논거를 점검하세요.');
        }

        function updatePeerPanelHeader(stage){
          const label = getStageLabel(stage);
          if (!label) return;
          const combined = label.headline ? `${label.name} · ${label.headline}` : label.name;
          setText('peerStageTitle', combined || '동료 토론');
          setText('peerStageSubtitle', label.description || '동료와 상호작용하며 피드백을 주고받으세요.');
        }

        function togglePanel(id, visible){
          const el = $(id);
          if (!el) return;
          el.style.display = visible ? 'flex' : 'none';
        }

        function renderPartnerPanel(){
          const partner = state.partner;
          const stage = Number(state.stage || 1);
          const nameEl = $('partnerName');
          const infoEl = $('partnerInfoBox');
          if (!nameEl || !infoEl) return;
          const isPeerStage = isPeerChatStage(stage);
          if (partner) {
            nameEl.textContent = (partner.name || '동료') + ' 학생';
            const peerStageName = formatStageName(partner.stage || 1);
            infoEl.textContent = (isPeerStage ? '동료와 실시간 피드백 단계입니다. 동료 단계: ' : '현재 단계: ') + peerStageName;
          } else {
            nameEl.textContent = '동료 정보를 불러오는 중...';
            if (isPeerStage) {
              infoEl.textContent = '동료 매칭 정보를 기다리고 있습니다.';
            } else {
              infoEl.textContent = '이 단계에서는 동료 정보가 필요하지 않습니다.';
            }
          }
        }

        function renderPresence(){
          const selfInfo = state.presence && state.presence.self;
          const partnerInfo = state.presence && state.presence.partner;
          const selfText = describePresence(selfInfo);
          const partnerText = describePresence(partnerInfo);
          $('peerPresenceSelf').textContent = selfText;
          $('peerPresencePartner').textContent = partnerText;
          updatePresenceDot('selfPresenceDot', selfInfo && selfInfo.online);
          updatePresenceDot('partnerPresenceDot', partnerInfo && partnerInfo.online);
        }

        function ensureAiWelcomeMessage(){
          if (!state.aiChat) return;
          if (state.aiChat.welcomeShown) return;
          const logEl = $('aiChatLog');
          if (!logEl) return;
          if (logEl.querySelector('.chat-line.system[data-welcome="true"]')) {
            state.aiChat.welcomeShown = true;
            return;
          }
          const label = getStageLabel(state.stage || 1);
          const welcomeText =
            (label && label.description) ||
            'AI 패널에 질문을 던지며 논거와 반론을 점검하세요.';
          const appended = appendChatMessage(
            'ai',
            {
              ts: 0,
              role: 'system',
              senderName: '시스템',
              text: welcomeText
            },
            { pending: false }
          );
          if (appended && appended.element) {
            appended.element.dataset.welcome = 'true';
          }
          state.aiChat.welcomeShown = true;
        }

        function setAiPending(waiting){
          if (!state.aiChat) return;
          state.aiChat.awaitingResponse = !!waiting;
          refreshChatControls();
        }

        function updatePresenceDot(id, online){
          const dot = $(id);
          if (!dot) return;
          dot.classList.toggle('presence-online', !!online);
          dot.classList.toggle('presence-offline', !online);
        }

        function renderDictionaryHistory(){
          const historyEl = $('dictHistory');
          const emptyEl = $('dictEmpty');
          if (!historyEl || !emptyEl) return;
          historyEl.innerHTML = '';
          if (!state.dictionaryHistory.length) {
            emptyEl.style.display = 'block';
            return;
          }
          emptyEl.style.display = 'none';
          state.dictionaryHistory.slice(-5).reverse().forEach(function(entry){
            const row = document.createElement('div');
            row.className = 'history-item';
            const term = document.createElement('span');
            term.className = 'term';
            term.textContent = entry.word || '';
            const arrow = document.createElement('span');
            arrow.className = 'direction';
            arrow.textContent = formatDictionaryDirection(entry.direction) || '→';
            const summary = document.createElement('span');
            summary.className = 'translation';
            summary.textContent = entry.summary || '';
            const time = document.createElement('span');
            time.className = 'time';
            time.textContent = formatTime(entry.timestamp);
            row.appendChild(term);
            row.appendChild(arrow);
            row.appendChild(summary);
            row.appendChild(time);
            row.addEventListener('click', function(){
              if (entry.data) renderDictionaryResult(entry.data);
            });
            historyEl.appendChild(row);
          });
        }

        function refreshChatControls(){
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const aiEnabled = !!state.aiChat.sessionId && (stage >= 1 && stage <= 5);
          const aiPending = state.aiChat && state.aiChat.awaitingResponse;
          const aiInput = $('aiInput');
          const aiBtn = $('btnAiSend');
          if (aiInput) aiInput.disabled = !aiEnabled || aiPending;
          if (aiBtn) aiBtn.disabled = !aiEnabled || aiPending;
          const peerEnabled = !!state.peerChat.sessionId && ((stage === 2 && group === 'B') || (stage === 3 && group === 'A'));
          $('peerInput').disabled = !peerEnabled;
          $('btnPeerSend').disabled = !peerEnabled;
        }

        function onSubmitPrewriting(){
          if (!hasGas) return;
          if (!state.sessionKey) { setStatus('세션이 활성화되지 않았습니다.', 'error'); return; }
          const text = $('prewritingInput').value.trim();
          if (!text) { setStatus('사전 글쓰기 내용을 입력하세요.', 'warn'); return; }
          $('btnPreSubmit').disabled = true;
          setStatus('사전 글쓰기를 제출하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            state.stage = Math.max(2, Number(state.stage || 1));
            setStatus('사전 글쓰기가 제출되었습니다. 2단계를 진행하세요.', 'success');
            syncSessionState(res);
            if (state.stage < 2) {
              state.stage = 2;
              renderWorkspace();
            }
          }).withFailureHandler(function(err){
            $('btnPreSubmit').disabled = false;
            handleError(err);
          }).submitPrewriting(state.sessionKey, text);
        }

        function onSaveDraft(){
          if (!hasGas) return;
          if (state.lastDraftSaveTime && Date.now() - state.lastDraftSaveTime < 2000) {
             setStatus('잠시 후 다시 저장해주세요.', 'warn');
             return;
          }
          state.lastDraftSaveTime = Date.now();
          const text = $('draftInput').value.trim();
          if (!text) { setStatus('2단계 메모를 입력하세요.', 'warn'); return; }
          $('btnSaveDraft').disabled = true;
          setStatus('2단계 메모를 저장하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            state.localDraftBuffer = text;
            setStatus('2단계 메모가 저장되었습니다.', 'success');
            syncSessionState(res);
          }).withFailureHandler(function(err){
            $('btnSaveDraft').disabled = false;
            handleError(err);
          }).savePostDraft(state.sessionKey, text);
        }

        function onAdvanceToPeerStage(){
          if (!hasGas) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          if (stage === 2 && group === 'A') {
            if (!confirm('동료 메모 단계로 이동하시겠습니까?')) return;
            $('btnToPeer').disabled = true;
            setStatus('동료 메모 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('동료 메모 단계가 열렸습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              $('btnToPeer').disabled = false;
              handleError(err);
            }).advanceToPeerStage(state.sessionKey);
          } else if (stage === 2 && group === 'B') {
            if (!confirm('AI 피드백 단계로 이동하시겠습니까?')) return;
            $('btnToPeer').disabled = true;
            setStatus('AI 피드백 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('AI 피드백 단계가 열렸습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              $('btnToPeer').disabled = false;
              handleError(err);
            }).advanceToPeerStage(state.sessionKey);
          } else if (stage === 2 && group === 'C') {
            if (!confirm('최종 단계로 이동하시겠습니까?')) return;
            $('btnToPeer').disabled = true;
            setStatus('최종 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('최종 단계로 이동했습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              $('btnToPeer').disabled = false;
              handleError(err);
            }).advanceToPeerStage(state.sessionKey);
        } else {
            setStatus('현재 단계에서는 이동할 수 없습니다.', 'warn');
          }
        }

        function onPeerNextStage(){
          if (!hasGas) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const btn = $('btnPeerNext');
          if (stage === 3 && (group === 'A' || group === 'B')) {
            if (!confirm('최종 단계로 이동하시겠습니까?')) return;
            if (btn) btn.disabled = true;
            setStatus('최종 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('최종 단계로 이동했습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              if (btn) btn.disabled = false;
              handleError(err);
            }).advanceToFinalStage(state.sessionKey);
        } else {
            setStatus('현재 단계에서는 이동할 수 없습니다.', 'warn');
          }
        }

        function onGoToPreviousStage(event){
          if (!hasGas) return;
          if (!state.sessionKey) { setStatus('세션이 활성화되지 않았습니다.', 'error'); return; }
          const currentStage = Number(state.stage || 1);
          const prevStage = getPreviousStageNumber();
          if (prevStage >= currentStage) {
            setStatus('이전 단계가 없습니다.', 'warn');
            return;
          }
          const prevLabel = formatStageName(prevStage) || (prevStage + '단계');
          if (!confirm(prevLabel + '로 이동하시겠습니까?')) return;
          const trigger = event && event.currentTarget;
          if (trigger) trigger.disabled = true;
          state.stageChangePending = true;
          updateStepIndicator();
          setStatus(prevLabel + '로 이동하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            if (trigger) trigger.disabled = false;
            state.stageChangePending = false;
            if (res && res.stage) {
              if (Number(res.stage) < Number(state.stage || 1)) {
                state.stage = Number(res.stage);
              }
              syncSessionState(res);
              setStatus(formatStageName(res.stage) + '로 이동했습니다.', 'success');
            } else {
              setStatus('이전 단계로 이동했습니다.', 'success');
              syncSessionState(res || {});
            }
          }).withFailureHandler(function(err){
            if (trigger) trigger.disabled = false;
            state.stageChangePending = false;
            updateStepIndicator();
            handleError(err);
          }).regressStage(state.sessionKey);
        }

        function onSavePeerNotes(){
          if (!hasGas) return;
          if (state.lastPeerNotesSaveTime && Date.now() - state.lastPeerNotesSaveTime < 2000) {
             setStatus('잠시 후 다시 저장해주세요.', 'warn');
             return;
          }
          state.lastPeerNotesSaveTime = Date.now();
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const isMemoStage = stage === 3 && (group === 'A' || group === 'B');
          if (!isMemoStage) { setStatus('3단계 메모 단계에서만 저장할 수 있습니다.', 'warn'); return; }
          const text = $('notesInput').value || '';
          if (!text.trim()) {
            $('btnNotesSave').disabled = false;
            setStatus('3단계 메모를 입력하세요.', 'warn');
            return;
          }
          $('btnNotesSave').disabled = true;
          setStatus('3단계 메모를 저장하는 중입니다...', 'info');
          const cleanedText = text.trim();
          google.script.run.withSuccessHandler(function(res){
            state.localStage3Memo = cleanedText;
            setStatus('3단계 메모가 저장되었습니다.', 'success');
            syncSessionState(res);
          }).withFailureHandler(function(err){
            $('btnNotesSave').disabled = false;
            handleError(err);
          }).savePeerNotes(state.sessionKey, cleanedText);
        }
        function onSubmitFinalWriting(){
          if (!hasGas) return;
          const stage = Number(state.stage || 1);
          if (stage !== 4) { setStatus('최종 단계에서만 제출할 수 있습니다.', 'warn'); return; }
          const textArea = $('finalInput');
          const content = (state.localFinalDraft || (textArea ? textArea.value : '') || '').trim();
          if (!content) { setStatus('최종 글을 작성하세요.', 'warn'); return; }
          if (!confirm('현재 작성한 최종 글을 제출하시겠습니까? 제출 후에는 수정할 수 없습니다.')) return;
          const btn = $('btnFinalSubmit');
          if (btn) btn.disabled = true;
          setStatus('최종 결과를 제출하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            setStatus('최종 제출이 완료되었습니다.', 'success');
            syncSessionState(res);
          }).withFailureHandler(function(err){
            if (btn) btn.disabled = false;
            handleError(err);
          }).submitFinalWriting(state.sessionKey, content);
        }

        function extractPrimaryMeaning(data){
          if (!data || !Array.isArray(data.entries)) return '';
          for (var i = 0; i < data.entries.length; i++) {
            var entry = data.entries[i];
            if (!entry || !Array.isArray(entry.meanings)) continue;
            for (var j = 0; j < entry.meanings.length; j++) {
              var meaning = entry.meanings[j];
              if (meaning && String(meaning).trim()) {
                return String(meaning).trim();
              }
            }
          }
          return '';
        }

        function resolveDictionaryDirection(data, fallbackQuery){
          if (data && data.direction) return data.direction;
          var source = '';
          if (data && data.word) source = String(data.word);
          if (!source && fallbackQuery) source = String(fallbackQuery);
          if (!source) return 'en-ko';
          var hasHangul = /[\u3131-\u318E\uAC00-\uD7A3]/.test(source);
          var hasLatin = /[A-Za-z]/.test(source);
          if (hasHangul && !hasLatin) return 'ko-en';
          if (hasLatin && !hasHangul) return 'en-ko';
          return hasHangul ? 'ko-en' : 'en-ko';
        }

        function formatDictionaryDirection(direction){
          if (direction === 'ko-en') return '한→영';
          if (direction === 'en-ko') return '영→한';
          return '';
        }

        function onDictionarySearch(){
          if (!hasGas) return;
          const query = $('dictQuery').value.trim();
          if (!query) { setStatus('검색어를 입력하세요.', 'warn'); return; }
          $('btnDictSearch').disabled = true;
          setStatus('사전을 조회하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            $('btnDictSearch').disabled = false;
            if (res && res.ok && res.data) {
              const direction = resolveDictionaryDirection(res.data, query);
              const normalizedData = Object.assign({}, res.data, { direction: direction });
              renderDictionaryResult(normalizedData);
              const primaryMeaning = extractPrimaryMeaning(normalizedData);
              const historyEntry = {
                word: normalizedData.word || query,
                pronunciation: normalizedData.pronunciation || '',
                summary: primaryMeaning,
                direction: normalizedData.direction,
                timestamp: Date.now(),
                data: normalizedData
              };
              state.dictionaryHistory.push(historyEntry);
              if (state.dictionaryHistory.length > 10) state.dictionaryHistory = state.dictionaryHistory.slice(-10);
              renderDictionaryHistory();
              setStatus('사전 검색 결과가 업데이트되었습니다.', 'success');
        } else {
              renderDictionaryResult(null, res && res.message ? res.message : '사전 결과가 없습니다.');
              setStatus(res && res.message ? res.message : '사전 검색에 실패했습니다.', 'warn');
            }
          }).withFailureHandler(function(err){
            $('btnDictSearch').disabled = false;
            renderDictionaryResult(null, err && err.message ? err.message : '사전 검색 중 오류가 발생했습니다.');
            handleError(err);
          }).lookupDictionary(query);
        }

        function renderDictionaryResult(data, message){
          const result = $('dictResult');
          if (!result) return;
          result.innerHTML = '';
          if (!data) {
            const word = document.createElement('div');
            word.className = 'dict-word';
            word.textContent = message || '검색 결과가 없습니다.';
            result.appendChild(word);
          return;
        }
          const direction = resolveDictionaryDirection(data);
          const directionLabel = formatDictionaryDirection(direction);
          const primaryMeaning = extractPrimaryMeaning(data);
          const headingParts = [];
          if (directionLabel) headingParts.push(directionLabel);
          if (data.word) headingParts.push(data.word);
          if (primaryMeaning && primaryMeaning !== data.word) headingParts.push(primaryMeaning);
          const headingEl = document.createElement('div');
          headingEl.className = 'dict-word';
          headingEl.textContent = headingParts.length ? headingParts.join(' · ') : (data.word || '사전 검색 결과');
          result.appendChild(headingEl);
          if (data.pronunciation) {
            const pron = document.createElement('div');
            pron.className = 'dict-pron';
            pron.textContent = data.pronunciation;
            result.appendChild(pron);
          }
          if (Array.isArray(data.entries) && data.entries.length) {
            const entriesWrap = document.createElement('div');
            entriesWrap.className = 'dict-section';
            data.entries.forEach(function(entry){
              const item = document.createElement('div');
              item.className = 'dict-entry';
              const pos = document.createElement('strong');
              pos.textContent = entry.pos || '';
              item.appendChild(pos);
              if (Array.isArray(entry.meanings) && entry.meanings.length) {
                const list = document.createElement('ul');
                list.style.margin = '6px 0 0 12px';
                list.style.padding = '0';
                list.style.listStyle = 'disc';
                entry.meanings.forEach(function(m){
                  const li = document.createElement('li');
                  li.textContent = m;
                  list.appendChild(li);
                });
                item.appendChild(list);
              }
              entriesWrap.appendChild(item);
            });
            result.appendChild(entriesWrap);
          }
          if (Array.isArray(data.examples) && data.examples.length) {
            const examplesWrap = document.createElement('div');
            examplesWrap.className = 'dict-examples';
            data.examples.forEach(function(example){
              const row = document.createElement('div');
              row.className = 'dict-example';
              const primaryKey = direction === 'ko-en' ? 'ko' : 'en';
              const secondaryKey = direction === 'ko-en' ? 'en' : 'ko';
              const primaryDiv = document.createElement('div');
              primaryDiv.style.color = '#1f2937';
              primaryDiv.style.fontWeight = '600';
              primaryDiv.textContent = example[primaryKey] || '';
              const secondaryDiv = document.createElement('div');
              secondaryDiv.style.color = '#2563eb';
              secondaryDiv.textContent = example[secondaryKey] || '';
              row.appendChild(primaryDiv);
              row.appendChild(secondaryDiv);
              examplesWrap.appendChild(row);
            });
            result.appendChild(examplesWrap);
          }
        }

        function sendAiMessage(){
          if (!hasGas) return;
          if (!state.aiChat.sessionId) { setStatus('AI 세션이 준비되지 않았습니다.', 'error'); return; }
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          if (!isAiChatStage(stage, group)) {
            setStatus('AI 피드백 단계에서만 사용할 수 있습니다.', 'warn');
            return;
          }
          const input = $('aiInput');
          if (!input || input.disabled) return;
          const text = input.value.trim();
          if (!text) return;
          input.value = '';
          const localMessage = { ts: Date.now(), role: 'user', senderId: state.user.id, senderName: state.user.name, text: text };
          const appended = appendChatMessage('ai', localMessage, { pending: true });
          setAiPending(true);
          setAiLoading(true);
        google.script.run.withSuccessHandler(function(res){
            if (appended && appended.tempId && res && typeof res.ts === 'number') {
              confirmChatMessage('ai', appended.tempId, res.ts, localMessage);
            }
            pollAiMessages();
          google.script.run.withSuccessHandler(function(ai){
              if (ai && ai.text) pollAiMessages();
            }).withFailureHandler(function(err){
              setAiLoading(false);
              setAiPending(false);
              handleError(err);
            }).requestAiIfNeeded(state.aiChat.sessionId, state.group, text, '', { channel: 'ai-feedback', sessionKey: state.sessionKey, stage: state.stage });
          }).withFailureHandler(function(err){
            setAiLoading(false);
            setAiPending(false);
            if (appended && appended.element) appended.element.classList.add('error');
            handleError(err);
          }).postMessage(state.aiChat.sessionId, state.group, state.user.id, state.user.name, 'user', text, { channel: 'ai-feedback', sessionKey: state.sessionKey, stage: state.stage });
        }

        function setAiLoading(flag){
          const loader = $('aiChatLoader');
          if (loader) loader.style.display = flag ? 'flex' : 'none';
          if (flag) {
            $('btnAiSend').disabled = true;
          } else {
            refreshChatControls();
          }
        }

        function sendPeerMessage(){
          if (!hasGas || !state.peerChat.sessionId) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const isPeerStage = (stage === 2 && group === 'B') || (stage === 3 && group === 'A');
          if (!isPeerStage) { setStatus('동료 협업 단계에서만 사용할 수 있습니다.', 'warn'); return; }
          const input = $('peerInput');
          if (!input || input.disabled) return;
          const text = input.value.trim();
          if (!text) return;
          input.value = '';
          const local = { ts: Date.now(), role: 'user', senderId: state.user.id, senderName: state.user.name, text: text };
          const appended = appendChatMessage('peer', local, { pending: true });
        google.script.run.withSuccessHandler(function(res){
            if (appended && appended.tempId && res && typeof res.ts === 'number') {
              confirmChatMessage('peer', appended.tempId, res.ts, local);
            }
            pollPeerMessages();
          }).withFailureHandler(function(err){
            if (appended && appended.element) appended.element.classList.add('error');
            handleError(err);
          }).postMessage(state.peerChat.sessionId, state.group, state.user.id, state.user.name, 'user', text, { channel: 'peer-chat', sessionKey: state.sessionKey, roomId: state.peerChat.sessionId });
        }

        function buildChatDedupeKey(message, ts){
          const time = Number(ts || message.ts || 0) || 0;
          const sender = String(message.senderId || message.role || '');
          const text = String(message.text || '');
          return time + '|' + sender + '|' + text;
        }

        function appendChatMessage(channel, message, options){
          const chatState = channel === 'ai' ? state.aiChat : state.peerChat;
          const logEl = $(channel === 'ai' ? 'aiChatLog' : 'peerChatLog');
          if (!chatState || !logEl) return null;
          const isPending = options && options.pending;
          const ts = Number(message.ts || Date.now());
          const dedupeKey = buildChatDedupeKey(message, ts);
          if (!isPending) {
            if (chatState.pending && Object.keys(chatState.pending).length) {
              let matchedTempId = '';
              Object.keys(chatState.pending).forEach(function(tempId){
                if (matchedTempId) return;
                const pendingNode = chatState.pending[tempId];
                if (!pendingNode) return;
                const pendingSender = pendingNode.dataset.senderId || '';
                if (String(pendingSender) !== String(message.senderId || '')) return;
                const bubbleEl = pendingNode.querySelector('.chat-bubble');
                if (!bubbleEl) return;
                if (bubbleEl.textContent === (message.text || '')) {
                  matchedTempId = tempId;
                }
              });
              if (matchedTempId) {
                const pendingNode = chatState.pending[matchedTempId];
                delete chatState.pending[matchedTempId];
                pendingNode.classList.remove('pending');
                if (ts) pendingNode.dataset.ts = String(ts);
                const metaEl = pendingNode.querySelector('.chat-meta');
                if (metaEl) metaEl.textContent = buildChatMeta(channel, message, ts, false);
                chatState.rendered[dedupeKey] = true;
                if (ts > chatState.lastTs) chatState.lastTs = ts;
                if (channel === 'ai' && message.role === 'ai') {
                  setAiPending(false);
                  setAiLoading(false);
                }
                return { tempId: matchedTempId, element: pendingNode };
              }
            }
            if (chatState.rendered[dedupeKey]) return null;
            chatState.rendered[dedupeKey] = true;
            if (ts > chatState.lastTs) chatState.lastTs = ts;
          }
          const tempId = isPending ? ('tmp-' + Date.now() + '-' + Math.random().toString(16).slice(2)) : '';
          const wrapper = document.createElement('div');
          wrapper.className = 'chat-line';
          if (isPending) wrapper.classList.add('pending');
          const role = message.role || 'user';
          wrapper.dataset.role = role;
          wrapper.dataset.senderName = message.senderName || '';
          wrapper.dataset.senderId = message.senderId || '';
          if (role === 'system') {
            wrapper.classList.add('system');
          } else if (role === 'ai') {
            wrapper.classList.add('ai');
          } else if (String(message.senderId || '') === String(state.user.id || '')) {
            wrapper.classList.add('me');
          } else {
            wrapper.classList.add('other');
          }
          if (tempId) wrapper.dataset.tempId = tempId;
          if (!isPending && ts) wrapper.dataset.ts = String(ts);
          const bubble = document.createElement('div');
          bubble.className = 'chat-bubble';
          bubble.innerHTML = formatChatText(message);
          const meta = document.createElement('div');
          meta.className = 'chat-meta';
          meta.textContent = buildChatMeta(channel, message, ts, isPending);
          const contentWrap = document.createElement('div');
          contentWrap.className = 'chat-content';
          contentWrap.appendChild(bubble);
          contentWrap.appendChild(meta);
          const avatarUrl = role === 'ai' ? (state.aiAvatarUrl || publicConfig.aiAvatarUrl || DEFAULT_AI_AVATAR) : '';
          if (avatarUrl) {
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            avatar.style.backgroundImage = `url('${avatarUrl}')`;
            wrapper.appendChild(avatar);
            wrapper.classList.add('with-avatar');
          }
          wrapper.appendChild(contentWrap);
          logEl.appendChild(wrapper);
          logEl.scrollTop = logEl.scrollHeight;
          if (!isPending && channel === 'ai') {
            recordAiTranscript(message, ts);
          }
          if (!isPending && channel === 'ai' && role === 'ai') {
            setAiPending(false);
            setAiLoading(false);
          }
          if (isPending) {
            chatState.pending[tempId] = wrapper;
          }
          return { tempId: tempId, element: wrapper };
        }

        function formatChatText(message){
          const text = String(message.text || '');
          if (!text) return '';
          if (message.role === 'ai' || message.role === 'system') {
            return renderMarkdown(text);
          }
          return escapeHtml(text).replace(/\n/g, '<br/>');
        }

        function escapeHtml(str){
          if (typeof str !== 'string') return '';
          return str.replace(/[&<>"']/g, function(ch){
            switch (ch) {
              case '&':
                return '&amp;';
              case '<':
                return '&lt;';
              case '>':
                return '&gt;';
              case '"':
                return '&quot;';
              case '\'':
                return '&#39;';
              default:
                return ch;
            }
          });
        }

        function renderMarkdown(text){
          if (!text) return '';
          const codeBlocks = [];
          let working = text.replace(/```([\s\S]*?)```/g, function(_match, code){
            const placeholder = `@@CODE_BLOCK_${codeBlocks.length}@@`;
            codeBlocks.push(`<pre><code>${escapeHtml(code)}</code></pre>`);
            return placeholder;
          });
          working = escapeHtml(working);
          working = working.replace(/`([^`]+)`/g, (_match, code) => `<code>${code}</code>`);
          working = working.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
          working = working.replace(/__(.+?)__/g, '<strong>$1</strong>');
          working = working.replace(/\*(?!\s)([^*]+)\*/g, '<em>$1</em>');
          working = working.replace(/_(?!\s)([^_]+)_/g, '<em>$1</em>');
          working = working.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
          working = working.replace(/(https?:\/\/[^\s<]+[^<.,;:)\s])/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
          working = convertMarkdownLists(working);
          working = working.replace(/\n{2,}/g, '<br/><br/>').replace(/\n/g, '<br/>');
          codeBlocks.forEach((block, idx) => {
            working = working.replace(`@@CODE_BLOCK_${idx}@@`, block);
          });
          return working;
        }

        function convertMarkdownLists(str){
          const unordered = str.replace(/(^|\n)([-*]\s.+(?:\n[-*]\s.+)*)/g, function(match, prefix, body){
            const lines = body
              .split('\n')
              .map((line) => line.replace(/^[-*]\s+/, '').trim())
              .filter(Boolean);
            if (!lines.length) return match;
            return `${prefix}<ul>${lines.map((item) => `<li>${item}</li>`).join('')}</ul>`;
          });
          return unordered.replace(/(^|\n)(\d+\.\s.+(?:\n\d+\.\s.+)*)/g, function(match, prefix, body){
            const lines = body
              .split('\n')
              .map((line) => line.replace(/^\d+\.\s+/, '').trim())
              .filter(Boolean);
            if (!lines.length) return match;
            return `${prefix}<ol>${lines.map((item) => `<li>${item}</li>`).join('')}</ol>`;
          });
        }

        function confirmChatMessage(channel, tempId, serverTs, original){
          const chatState = channel === 'ai' ? state.aiChat : state.peerChat;
          if (!chatState || !chatState.pending) return;
          const el = chatState.pending[tempId];
          if (!el) return;
          delete chatState.pending[tempId];
          el.classList.remove('pending');
          el.dataset.ts = String(serverTs);
          const dedupeKey = buildChatDedupeKey(original || {}, serverTs);
          chatState.rendered[dedupeKey] = true;
          chatState.lastTs = Number(serverTs) || chatState.lastTs;
          const meta = el.querySelector('.chat-meta');
          if (meta) {
            meta.textContent = buildChatMeta(channel, original || { role: 'user', senderName: state.user.name, senderId: state.user.id }, serverTs, false);
          }
        }

        function buildChatMeta(channel, message, ts, pending){
          let name = '';
          if (message.role === 'ai') name = channel === 'ai' ? 'AI 튜터' : 'AI';
          else if (message.role === 'system') name = '시스템';
          else name = message.senderName || message.senderId || '사용자';
          return name + ' · ' + (pending ? '전송 중...' : formatTime(ts));
        }

        function pollAiMessages(){
          if (!hasGas || !state.aiChat.sessionId) return;
          const stage = Number(state.stage || 1);
          if (!isAiChatStage(stage)) return;
          if (state.aiChat.fetching) return;
          state.aiChat.fetching = true;
          google.script.run.withSuccessHandler(function(list){
            state.aiChat.fetching = false;
            if (!Array.isArray(list)) return;
            list.forEach(function(msg){ appendChatMessage('ai', msg, { pending: false }); });
          }).withFailureHandler(function(err){
            state.aiChat.fetching = false;
            console.error(err);
          }).getMessages(state.aiChat.sessionId, state.aiChat.lastTs, 'ai-feedback');
        }

        function startAiPolling(){
          if (state.timers.ai) return;
          const stage = Number(state.stage || 1);
          if (!isAiChatStage(stage)) return;
          state.timers.ai = setInterval(pollAiMessages, 5000);
          pollAiMessages();
        }

        function stopAiPolling(){
          if (state.timers.ai) {
            clearInterval(state.timers.ai);
            state.timers.ai = null;
          }
        }

        function pollPeerMessages(){
          if (!hasGas || !state.peerChat.sessionId) return;
          const stage = Number(state.stage || 1);
          if (!isPeerChatStage(stage)) return;
          if (state.peerChat.fetching) return;
          state.peerChat.fetching = true;
          google.script.run.withSuccessHandler(function(list){
            state.peerChat.fetching = false;
            if (!Array.isArray(list)) return;
            list.forEach(function(msg){ appendChatMessage('peer', msg, { pending: false }); });
          }).withFailureHandler(function(err){
            state.peerChat.fetching = false;
            console.error(err);
          }).getMessages(state.peerChat.sessionId, state.peerChat.lastTs, 'peer-chat');
        }

        function startPeerPolling(){
          if (state.timers.peer) return;
          const stage = Number(state.stage || 1);
          if (!isPeerChatStage(stage)) return;
          state.timers.peer = setInterval(pollPeerMessages, 5000);
          pollPeerMessages();
        }

        function stopPeerPolling(){
          if (state.timers.peer) {
            clearInterval(state.timers.peer);
            state.timers.peer = null;
          }
        }

        function refreshSessionState(){
          if (!hasGas || !state.sessionKey || state.refreshingState) return;
          state.refreshingState = true;
        google.script.run.withSuccessHandler(function(res){
            state.refreshingState = false;
            syncSessionState(res);
          }).withFailureHandler(function(err){
            state.refreshingState = false;
            console.error(err);
          }).getSessionState(state.sessionKey);
        }

        function startStatePolling(){
          if (state.timers.state) return;
          state.timers.state = setInterval(refreshSessionState, 5000);
        }

        function startPresencePing(){
          if (state.timers.presence) return;
          state.timers.presence = setInterval(sendPresencePing, 10000);
        }

        function sendPresencePing(){
          if (!hasGas || !state.sessionKey) return;
          try { google.script.run.touchPresence(state.sessionKey); } catch (e) { console.error(e); }
        }

        function ensurePollers(){
          if (!state.sessionKey) return;
          startStatePolling();
          startPresencePing();
          const stage = Number(state.stage || 1);
          const isAiStage = isAiChatStage(stage);
          const isPeerStage = isPeerChatStage(stage);
          if (isAiStage && state.aiChat.sessionId) startAiPolling(); else stopAiPolling();
          if (isPeerStage && state.peerChat.sessionId) startPeerPolling(); else stopPeerPolling();
          if (stage >= 4) {
            stopAiPolling();
            stopPeerPolling();
          }
        }

        function clearAllTimers(){
          ['ai','peer','state','presence'].forEach(function(key){
            if (state.timers[key]) {
              clearInterval(state.timers[key]);
              state.timers[key] = null;
            }
          });
        }

        function clearChatLog(channel, options){
          const opts = options || {};
          const logEl = $(channel === 'ai' ? 'aiChatLog' : 'peerChatLog');
          if (logEl) logEl.innerHTML = '';
          const chatState = channel === 'ai' ? state.aiChat : state.peerChat;
          if (!opts.keepLastTs) {
            chatState.lastTs = 0;
          }
          chatState.rendered = {};
          chatState.pending = {};
          chatState.fetching = false;
          if (channel === 'ai') {
            chatState.awaitingResponse = false;
            chatState.welcomeShown = false;
          }
        }

        function setStatus(message, type){
          state.status = { message: message, type: type || 'info' };
          const bar = $('statusBar');
          if (!bar) return;
          bar.textContent = message;
          bar.className = 'status-bar ' + (type || 'info');
        }

        function handleError(err){
          let msg = err && err.message ? err.message : (typeof err === 'string' ? err : '알 수 없는 오류가 발생했습니다.');
          if (msg.includes('429') || msg.includes('rate limit') || msg.includes('quota')) {
            msg = '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.';
          }
          console.error(err);
          setStatus(msg, 'error');
        }

        function formatDate(ms){
          if (!ms) return '';
          return new Date(ms).toLocaleString('ko-KR', { hour12: false });
        }

        function formatTime(ms){
          if (!ms) return '';
          return new Date(ms).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
        }

        function formatStageName(step){
          const label = getStageLabel(step);
          return label?.name || `단계 ${step}`;
        }

        function describePresence(info){
          if (!info) return '오프라인';
          if (info.online) return '온라인 · ' + formatRelative(info.lastSeen || Date.now());
          if (info.lastSeen) return '오프라인 · 마지막 접속 ' + formatRelative(info.lastSeen);
          return '오프라인';
        }

        function formatRelative(ms){
          if (!ms) return '';
          const diff = Date.now() - ms;
          if (diff < 0) return '방금';
          const seconds = Math.floor(diff / 1000);
          if (seconds < 60) return '방금';
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + '분 전';
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + '시간 전';
          const days = Math.floor(hours / 24);
          return days + '일 전';
        }

        function loadPublicSettings(){
          if (!hasGas) return;
          try {
            google.script.run.withSuccessHandler(function(cfg){
              if (!cfg) return;
              publicConfig.aiAvatarUrl = cfg.aiAvatarUrl || DEFAULT_AI_AVATAR;
              publicConfig.promptContent = cfg.promptContent || '';
              publicConfig.stageLabelsByType[TYPE_KEYS.TYPE_A] = normalizeStageLabels(
                cfg.stageLabels,
                DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A]
              );
              publicConfig.stageLabelsByType[TYPE_KEYS.TYPE_B] = normalizeStageLabels(
                cfg.stageLabelsTypeB,
                DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_B]
              );
              publicConfig.stagePromptsByType[TYPE_KEYS.TYPE_A] = normalizeStagePrompts(
                cfg.stagePrompts,
                DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A]
              );
              publicConfig.stagePromptsByType[TYPE_KEYS.TYPE_B] = normalizeStagePrompts(
                cfg.stagePromptsTypeB,
                DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_B]
              );
              state.aiAvatarUrl = publicConfig.aiAvatarUrl || DEFAULT_AI_AVATAR;
              buildStepIndicator();
              applyStageLabelsToPanels();
              renderStagePrompts();
              updateStepIndicator();
              renderRightPanels();
            }).getPublicSettings();
          } catch (e) {
            console.error(e);
          }
        }

        init();
      })();
    </script>
  </body>
</html>

 
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>토론 플랫폼</title>
    <style>
      *, *::before, *::after { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: 'Pretendard', 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f4f6fb; color: #1f2937; overflow: hidden; }
      textarea, input, button { font-family: inherit; }
      .page-container { max-width: 1200px; margin: 0 auto; padding: 12px 20px 16px; display: flex; flex-direction: column; gap: 12px; height: 100%; box-sizing: border-box; overflow: hidden; }
      .card { background: #ffffff; border-radius: 14px; border: 1px solid #e2e8f0; padding: 24px; box-shadow: 0 8px 24px rgba(15, 23, 42, 0.06); }
      .hero-card { text-align: center; }
      .hero-card h1 { margin: 0 0 12px; font-size: 26px; font-weight: 700; color: #111827; }
      .hero-card p { margin: 0 0 18px; color: #4b5563; font-size: 15px; }
      .group-buttons { display: flex; justify-content: center; gap: 16px; flex-wrap: wrap; }
      .group-button { min-width: 160px; padding: 18px 20px; border-radius: 12px; border: 1px solid #d0d7e3; background: linear-gradient(135deg, #f8fafc, #eef2ff); font-weight: 700; font-size: 16px; color: #1d4ed8; cursor: pointer; transition: transform 0.18s ease, box-shadow 0.18s ease; }
      .group-button:hover { transform: translateY(-4px); box-shadow: 0 14px 26px rgba(37, 99, 235, 0.18); }
      .group-button:active { transform: translateY(-1px); }
      .type-card { max-width: 720px; margin: 0 auto; text-align: center; }
      .type-card p { margin: 10px 0 20px; color: #475569; font-size: 14px; }
      .type-buttons { display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; }
      .type-option { flex: 1; min-width: 220px; padding: 18px; border-radius: 14px; border: 1px solid #cbd5f5; background: #f8fafc; display: flex; flex-direction: column; gap: 6px; align-items: flex-start; text-align: left; cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease; }
      .type-option:hover { transform: translateY(-2px); border-color: #94a3ff; }
      .type-option strong { font-size: 18px; color: #111827; }
      .type-option span { font-size: 13px; color: #475569; }
      .type-option.active { border-color: #2563eb; box-shadow: 0 12px 24px rgba(37, 99, 235, 0.2); background: #eef2ff; }
      .login-card { max-width: 520px; margin: 0 auto; }
      .login-header { display: flex; flex-direction: column; gap: 6px; margin-bottom: 18px; }
      .login-group-row { display: flex; align-items: center; gap: 8px; }
      .login-group-row .ghost { padding: 6px 10px; font-size: 12px; }
      .login-group { font-size: 18px; font-weight: 700; color: #1d4ed8; }
      .login-message { font-size: 13px; color: #64748b; }
      .login-card form { display: flex; flex-direction: column; gap: 16px; }
      .field { display: flex; flex-direction: column; gap: 6px; }
      label { font-size: 13px; font-weight: 600; color: #475569; }
      input[type="text"], textarea { width: 100%; border: 1px solid #d0d7e3; border-radius: 10px; padding: 12px; background: #ffffff; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
      input[type="text"]:focus, textarea:focus { border-color: #2563eb; outline: none; box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.12); }
      textarea { min-height: 180px; resize: vertical; line-height: 1.6; }
      button { cursor: pointer; transition: transform 0.15s ease, box-shadow 0.15s ease; }
      button:disabled { cursor: not-allowed; opacity: 0.6; box-shadow: none !important; transform: none !important; }
      .primary { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; border: none; border-radius: 10px; padding: 12px 18px; font-weight: 700; box-shadow: 0 8px 20px rgba(37, 99, 235, 0.25); }
      .primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 14px 28px rgba(37, 99, 235, 0.28); }
      .secondary { background: #f1f5f9; color: #1f2937; border: 1px solid #d0d7e3; border-radius: 10px; padding: 12px 18px; font-weight: 600; }
      .ghost { background: transparent; border: none; color: #2563eb; padding: 12px 16px; font-weight: 600; }
      .ghost:hover { text-decoration: underline; }
      .link-button { background: none; border: none; color: #2563eb; font-weight: 600; padding: 8px 12px; border-radius: 8px; }
      .link-button:hover { background: rgba(37, 99, 235, 0.1); }
      .login-actions { display: flex; gap: 12px; justify-content: flex-end; }
      .workspace { display: none; flex-direction: column; gap: 12px; flex: 1; overflow: hidden; min-height: 0; }
      .workspace-toolbar { display: flex; justify-content: space-between; align-items: center; gap: 12px; padding: 4px 0; }
      .user-info { font-size: 14px; font-weight: 600; color: #475569; }
      .status-bar { padding: 10px 14px; border-radius: 12px; border: 1px solid #cbd5f5; background: #eef2ff; color: #1e3a8a; font-size: 13px; line-height: 1.4; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4); }
      .status-bar.success { border-color: #bbf7d0; background: #ecfdf5; color: #047857; }
      .status-bar.warn { border-color: #fde68a; background: #fef3c7; color: #92400e; }
      .status-bar.error { border-color: #fecaca; background: #fee2e2; color: #b91c1c; }
      .step-indicator { display: flex; gap: 12px; flex-wrap: wrap; }
      .step-item { flex: 1; min-width: 150px; display: flex; align-items: center; gap: 10px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 10px 12px; transition: border-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease; }
      .step-number { min-width: 36px; padding: 0 6px; height: 32px; border-radius: 999px; background: #e2e8f0; color: #1f2937; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 13px; }
      .step-info { display: flex; flex-direction: column; gap: 2px; }
      .step-title { font-size: 14px; font-weight: 700; color: #1f2937; }
      .step-caption { font-size: 12px; color: #64748b; }
      .step-item.active { border-color: #2563eb; transform: translateY(-2px); box-shadow: 0 14px 26px rgba(37, 99, 235, 0.16); }
      .step-item.active .step-number { background: #2563eb; color: #ffffff; }
      .step-item.completed { border-color: #bbf7d0; }
      .step-item.completed .step-number { background: #10b981; color: #ffffff; }
      .workspace-grid { display: grid; gap: 16px; grid-template-columns: 1.1fr 0.9fr; flex: 1; min-height: 0; height: 100%; }
      .left-column, .right-column { display: flex; flex-direction: column; gap: 14px; min-height: 0; height: 100%; overflow-y: auto; padding-right: 6px; }
      .stage-panel { background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 18px; display: flex; flex-direction: column; gap: 12px; }
      .panel-header { display: flex; justify-content: space-between; align-items: center; gap: 12px; }
      .panel-header h2 { font-size: 18px; font-weight: 700; margin: 0; color: #111827; white-space: nowrap; }
      .panel-subtext { font-size: 13px; color: #64748b; }
      .panel-header.memo-stacked { flex-direction: column; align-items: flex-start; gap: 6px; }
      /* 2차시 메모 패널: 제목 아래에 설명 배치 */
      #panelPrompt .panel-header,
      #panelPrewriting .panel-header { flex-direction: column; align-items: flex-start; }
      #panelPrompt .panel-header h2,
      #panelPrewriting .panel-header h2 { white-space: normal; }
      #panelPrompt .panel-header .panel-subtext,
      #panelPrewriting .panel-header .panel-subtext { line-height: 1.6; }
      /* 동료 채팅은 비활성화 */
      .partner-box, .presence-status { display: none !important; }
      /* 3-1차시 메모 패널과 버튼 숨김 */
      #panelDraft { display: none; }
      /* 오른쪽 패널은 부제목을 헤더 아래에 세로로 배치 */
      .right-panel .panel-header { flex-direction: column; align-items: flex-start; }
      .right-panel .panel-header h2 { white-space: normal; }
      .right-panel .panel-header .panel-subtext { line-height: 1.6; }
      .readonly-block { display: none; padding: 12px; border-radius: 10px; border: 1px dashed #cbd5e1; background: #f8fafc; font-size: 14px; line-height: 1.7; color: #1f2937; white-space: pre-wrap; }
      .text-block { padding: 12px; border-radius: 10px; border: 1px solid #d8dee9; background: #f8fafc; font-size: 14px; line-height: 1.7; white-space: pre-wrap; color: #1f2937; }
      .button-row { display: flex; gap: 10px; justify-content: flex-end; }
      .meta-info { font-size: 12px; color: #64748b; }
      .right-panel { display: none; flex-direction: column; gap: 12px; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 18px; min-height: 360px; flex: none; overflow: visible; }
      .dictionary-search { display: flex; gap: 10px; }
      .dictionary-result { padding: 14px; border-radius: 10px; border: 1px solid #cbd5e1; background: #f8fafc; display: flex; flex-direction: column; gap: 8px; }
      .dict-word { font-size: 18px; font-weight: 700; color: #111827; }
      .dict-pron { font-size: 13px; color: #64748b; }
      .dict-section { display: flex; flex-direction: column; gap: 6px; }
      .dict-entry { padding: 8px 10px; border-radius: 8px; background: #fff; border: 1px solid #e2e8f0; }
      .dict-entry strong { font-size: 13px; color: #1f2937; }
      .dict-examples { display: flex; flex-direction: column; gap: 6px; }
      .dict-example { padding: 8px 10px; border-radius: 8px; background: #fff; border: 1px solid #e2e8f0; font-size: 13px; line-height: 1.5; }
      .dictionary-history { display: flex; flex-direction: column; gap: 8px; font-size: 13px; color: #64748b; }
      .history-item { display: flex; gap: 8px; align-items: center; padding: 10px 12px; border-radius: 10px; background: #f8fafc; border: 1px solid #e2e8f0; }
      .history-item .term { font-weight: 600; color: #1f2937; }
      .history-item .direction { font-weight: 600; color: #475569; }
      .history-item .translation { color: #2563eb; }
      .history-item .time { margin-left: auto; color: #94a3b8; font-size: 12px; }
      .prewriting-preview-block { display: flex; flex-direction: column; gap: 6px; }
      .prewriting-preview-block strong { font-size: 13px; color: #475569; }
      .stage3-preview-grid { display: flex; flex-direction: column; gap: 14px; }
      .stage3-transcript-block { border: 1px dashed #d0d7f3; background: #f5f8ff; border-radius: 10px; padding: 12px; }
      .stage3-transcript-list { display: flex; flex-direction: column; gap: 8px; max-height: 280px; overflow-y: auto; }
      .stage3-transcript-line { padding: 10px 12px; border-radius: 10px; border: 1px solid #dfe3f8; background: #fff; font-size: 13px; line-height: 1.45; color: #1f2937; }
      .stage3-transcript-line.ai { background: #eef2ff; border-color: #c7d2fe; }
      .stage3-transcript-line .label { display: block; font-weight: 600; color: #4338ca; margin-bottom: 4px; font-size: 12px; }
      .stage3-memo-helper { font-size: 12px; color: #6b7280; margin: -4px 0 0; }
      .chat-log { flex: 1; min-height: 320px; max-height: 320px; border: 1px solid #d0d7e3; border-radius: 12px; background: radial-gradient(circle at top, #f8fafc 0%, #ffffff 48%); padding: 12px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
      .chat-line { display: flex; flex-direction: column; gap: 4px; max-width: 80%; word-break: break-word; }
      .chat-line.me { align-self: flex-end; text-align: right; }
      .chat-line.ai, .chat-line.other { align-self: flex-start; }
      .chat-line.system { align-self: center; max-width: 100%; text-align: center; }
      .chat-bubble { padding: 10px 14px; border-radius: 14px; line-height: 1.6; background: #eef2ff; color: #1f2937; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08); font-size: 13px; }
      .chat-line.me .chat-bubble { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; border-bottom-right-radius: 6px; }
      .chat-line.ai .chat-bubble { background: #f8fafc; border: 1px solid #cbd5f5; border-bottom-left-radius: 6px; }
      .chat-line.system .chat-bubble { background: #f1f5f9; color: #475569; border: 1px dashed #cbd5e1; }
      .chat-bubble a { color: #1d4ed8; font-weight: 600; text-decoration: underline; }
      .chat-line.me .chat-bubble a { color: #dbeafe; }
      .chat-bubble a:hover { text-decoration: underline; }
      .chat-meta { font-size: 11px; color: #94a3b8; }
      .chat-line.me .chat-meta { align-self: flex-end; }
      .chat-line.pending .chat-meta::after { content: ' · 전송 중'; color: #f97316; }
      .chat-line.error .chat-bubble { border: 1px solid #f87171; }
      .chat-input { display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }
      .chat-input textarea { height: 96px; min-height: 96px; max-height: 96px; resize: none; overflow-y: auto; }
      #aiInput { height: 72px; min-height: 72px; max-height: 72px; }
      #notesInput { min-height: 90px; height: 90px; }
      #finalInput { min-height: 260px; }
      .chat-actions { display: flex; justify-content: flex-end; gap: 10px; }
      .spinner { display: none; align-items: center; gap: 8px; font-size: 13px; color: #64748b; }
      .partner-box { border: 1px solid #d0d7e3; border-radius: 12px; padding: 12px 14px; background: linear-gradient(135deg, #f8fafc, #f1f5f9); display: flex; flex-direction: column; gap: 6px; }
      .partner-box h3 { margin: 0; font-size: 16px; font-weight: 700; color: #1f2937; }
      .partner-meta { font-size: 12px; color: #64748b; }
      .presence-status { display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: #475569; }
      .presence-status span { display: flex; align-items: center; gap: 6px; }
      .presence-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
      .presence-online { background: #22c55e; }
      .presence-offline { background: #94a3b8; }
      .notes-helper { font-size: 12px; color: #94a3b8; }
      .final-grid { display: grid; gap: 12px; }
      @media (max-width: 1024px) {
        .workspace-grid { grid-template-columns: 1fr; }
        .right-column { order: -1; }
      }
      @media (max-width: 640px) {
        .page-container { padding: 12px 14px 16px; }
        .group-buttons { flex-direction: column; }
        .login-actions { flex-direction: column; align-items: stretch; }
        .step-item { min-width: 100%; }
        .chat-log { max-height: none; min-height: 260px; }
        .left-column { padding-right: 0; }
        .chat-input textarea { height: 90px; min-height: 90px; max-height: 90px; }
        #aiInput { height: 68px; min-height: 68px; max-height: 68px; }
        #finalInput { min-height: 200px; }
      }
      .chat-line.me .chat-content { align-items: flex-end; }
      .chat-line.ai.with-avatar { flex-direction: row; gap: 10px; max-width: 80%; }
      .chat-line.ai.with-avatar .chat-content { max-width: calc(100% - 48px); }
      .chat-line.ai.with-avatar .chat-meta { align-self: flex-start; }
      .chat-avatar { width: 36px; height: 36px; border-radius: 50%; background-size: cover; background-position: center; border: 1px solid #e2e8f0; flex-shrink: 0; margin-top: 2px; }
      .reference-block { border: 1px solid #e2e8f0; border-radius: 10px; background: #f8fafc; padding: 12px; display: flex; flex-direction: column; gap: 8px; }
      .reference-block strong { font-size: 13px; color: #1f2937; }
      .panel-block { display: flex; flex-direction: column; gap: 12px; margin-bottom: 18px; }
      .panel-block:last-of-type { margin-bottom: 0; }
      #rightStage1 { background: transparent; border: none; padding: 0; min-height: auto; }
      #rightStage1 .stage-panel { margin: 0; }
    </style>
    <script src="./app-config.js"></script>
  </head>
  <body>
    <div class="page-container">
      <div id="loginCard" class="card login-card">
        <div class="login-header">
          <div class="login-group-row">
            <div id="selectedTypeLabel" class="login-group">Type A · 기본</div>
          </div>
          <div id="loginMessage" class="login-message">식별번호와 이름을 정확하게 입력해주세요.</div>
          </div>
        <form id="loginForm">
          <div class="field">
            <label for="studentIdInput">식별 번호</label>
            <input id="studentIdInput" type="text" placeholder="예) A10100" autocomplete="off" />
        </div>
          <div class="field">
            <label for="studentNameInput">이름</label>
            <input id="studentNameInput" type="text" placeholder="이름을 입력하세요" autocomplete="off" />
        </div>
          <div class="login-actions">
            <button id="loginSubmit" class="primary" type="submit">실험 시작</button>
      </div>
        </form>
    </div>

      <div id="workspace" class="workspace">
        <div class="workspace-toolbar">
          <div id="userInfo" class="user-info"></div>
          <button id="btnRestart" class="link-button" type="button">처음으로 돌아가기</button>
          </div>
        <div id="statusBar" class="status-bar info">식별 번호와 이름을 입력하면 세션이 시작됩니다.</div>
        <div id="stepIndicator" class="step-indicator">
        </div>

        <div class="workspace-grid">
          <div class="left-column">
            <section id="panelPrompt" class="stage-panel" data-step="1">
              <div class="panel-header">
                <h2 id="promptStageTitle">2차시 · 토론 관련 발문</h2>
                <span id="promptStageSubtitle" class="panel-subtext">논제 이해를 위해 핵심 발문을 확인하세요. 필요 시 교사가 제시합니다.</span>
              </div>
              <div id="promptContent" class="text-block">토론 발문이 아직 등록되지 않았습니다.</div>
            </section>

            <section id="panelPrewriting" class="stage-panel" data-step="1">
              <div class="panel-header">
                <h2 id="prewritingTitle">2차시 · 메모장</h2>
                <span id="prewritingInfo" class="panel-subtext">인터넷 검색으로 찬성·반대 근거를 수집하며 메모를 남기세요.</span>
              </div>
              <textarea id="prewritingInput" placeholder="주장·근거, 출처, 의문점을 자유롭게 적어 두세요."></textarea>
              <div id="prewritingReadonly" class="readonly-block"></div>
              <div class="button-row">
                <button id="btnPreSubmit" class="primary" type="button" disabled>2차시 메모 저장</button>
              </div>
            </section>

            <section id="panelDraft" class="stage-panel" data-step="2">
              <div class="panel-header">
                <h2 id="draftTitle">3-1차시 · 토론 메모</h2>
                <span id="draftInfo" class="panel-subtext">ChatGPT와 1:1 모의 토론 중 떠오른 주장·근거·반론을 간단히 메모하세요.</span>
              </div>
              <div class="prewriting-preview-block">
                <strong>토론 관련 발문</strong>
                <div id="draftPromptContent" class="text-block">관리자가 등록한 발문이 여기에 표시됩니다.</div>
              </div>
              <div class="prewriting-preview-block">
                <strong>이전 메모/발문</strong>
                <div id="prewritingPreview" class="text-block">2차시 메모가 아직 저장되지 않았습니다.</div>
              </div>
              <textarea id="draftInput" placeholder="찬성/반대 주장, 근거, 추가 조사할 내용 등을 기록하세요."></textarea>
              <div class="button-row">
                <button id="btnSaveDraft" class="secondary" type="button" disabled>3-1차시 메모 저장</button>
              </div>
            </section>

            <section id="panelMemoStage3" class="stage-panel" data-step="3">
              <div class="panel-header memo-stacked">
                <h2 id="memoStage3Title">글쓰기 수정 관련 메모</h2>
                <span id="memoStage3Info" class="panel-subtext">
                  토론을 통해 느낀 점과 보완할 점에 대해 자유롭게 성찰하세요.<br/>
                  아래 항목을 참고하여 자유롭게 기록하세요.<br/>
                  - 토론을 통해 새롭게 알게 된 점은 무엇인가?<br/>
                  - ChatGPT의 반박 중 설득력이 있었다고 느낀 부분은 무엇인가?<br/>
                  - 내 주장이나 근거에서 잘 대응했다고 느낀 부분은 무엇인가?<br/>
                  - 내 주장이나 근거에서 보완이 필요하다고 느낀 점은 무엇인가?<br/>
                  - 논증 방식이나 사고 과정에서 성장했다고 느낀 점은 무엇인가?<br/>
                  - 다음 토론에서 개선하고 싶은 점은 무엇인가?
                </span>
              </div>
              <div class="stage3-preview-grid">
                <div class="stage3-transcript-block">
                  <strong id="stage3TranscriptHeading">3-1차시 토론 기록</strong>
                  <div id="stage3Transcript" class="stage3-transcript-list">
                    <div class="stage3-transcript-line">이전 토론 기록을 불러오는 중입니다.</div>
              </div>
              </div>
                <div>
              <label for="notesInput">3차시-2 토론 관련 성찰 메모</label>
              <textarea id="notesInput" placeholder="토론을 통해 느낀 점과 보완할 점에 대해 자유롭게 성찰한 뒤 작성하세요."></textarea>
              <p id="stage3MemoHelper" class="stage3-memo-helper">토론을 통해 느낀 점과 보완할 점에 대해 자유롭게 성찰하세요.</p>
              </div>
              </div>
              <div class="button-row">
                <button id="btnNotesSave" class="secondary" type="button" disabled>3단계 메모 저장</button>
              </div>
            </section>

            <section id="panelFinalSummary" class="stage-panel" data-step="4">
              <div class="panel-header memo-stacked">
                <h2 id="stage4Title">4차시-1 토론 안내</h2>
                <span id="stage4Subtitle" class="panel-subtext">
                  이제 ChatGPT는 다시 당신의 입장과 반대되는 관점을 가진 토론 상대자로 설정됩니다.<br/>
                  이번 차시에서는 이전 차시와 ‘반대 입장’에서 토론을 진행합니다.<br/>
                  당신이 반대 입장이므로, ChatGPT는 찬성 입장에서 토론합니다.<br/>
                  즉, 이번 차시는 기존에 주장했던 입장을 그대로 반복하는 것이 아니라, 반대 관점을 이해하고 그 입장에서 논증하는 활동입니다.
                </span>
              </div>
              <div id="stage4PromptContent" class="text-block">관리자가 등록한 발문이 여기에 표시됩니다.</div>
            </section>

            <section id="panelStage4Draft" class="stage-panel" data-step="4">
              <div class="panel-header" style="display:none;">
                <h2 id="stage4DraftTitle">4차시-1 토론 안내</h2>
                <span id="stage4DraftInfo" class="panel-subtext"></span>
              </div>
              <div class="prewriting-preview-block" style="display:none;">
                <strong>4차시-1 토론 발문</strong>
                <div id="stage4DraftPromptContent" class="text-block">관리자가 등록한 발문이 여기에 표시됩니다.</div>
              </div>
              <div class="prewriting-preview-block">
                <strong>2차시 메모</strong>
                <div id="stage4PrevMemoPreview" class="text-block">2차시 메모가 아직 저장되지 않았습니다.</div>
              </div>
              <div class="prewriting-preview-block">
                <strong>3차시-2 성찰 메모</strong>
                <div id="stage4Stage3MemoPreview" class="text-block">3차시-2 성찰 메모가 아직 없습니다.</div>
              </div>
              <textarea id="stage4DraftInput" placeholder="입장을 바꾼 4-1차시 토론에서 떠오른 주장·근거·반론을 메모하세요. (저장 비활성화)" style="display:none;"></textarea>
              <div class="button-row" style="display:none;">
                <button id="btnStage4DraftSave" class="secondary" type="button" disabled>4차시-1 메모 저장</button>
              </div>
            </section>

            <section id="panelStage5" class="stage-panel" data-step="5">
              <div class="panel-header">
                <h2 id="stage5Title">5차시 · 4-1 토론 요약 & 메모 (4-2)</h2>
                <span id="stage5Subtitle" class="panel-subtext">4-1차시 대화를 요약해 확인하고, 추가로 메모하세요.</span>
              </div>
          <div class="stage3-preview-grid" id="stage5ReviewGrid">
                <div class="stage3-transcript-block" id="stage5PrevMemoBlock">
                  <strong id="stage5PrevMemoHeading">3-2차시 성찰 메모</strong>
                  <div id="stage5PrevMemo" class="stage3-transcript-list">
                    <div class="stage3-transcript-line">3-2차시 메모가 아직 없습니다.</div>
                  </div>
                </div>
            <div class="stage3-transcript-block" id="stage5TranscriptBlock">
              <strong id="stage5TranscriptHeading">4-1차시 토론 기록</strong>
              <div id="stage5Transcript" class="stage3-transcript-list">
                <div class="stage3-transcript-line">4-1 토론 기록을 불러오는 중입니다.</div>
              </div>
            </div>
            <div>
              <label for="stage5MemoInput">평가 메모</label>
                  <textarea id="stage5MemoInput" placeholder="4-2차시 토론 관련 성찰 메모를 작성하세요."></textarea>
                  <p id="stage5MemoHelper" class="stage3-memo-helper">
                    토론을 통해 느낀 점과 보완할 점에 대해 자유롭게 성찰하세요. 1차 성찰 메모, 2차 토론 기록, ChatGPT와의 성찰 대화를 바탕으로 자신의 생각을 정리해보세요.
                    아래 항목을 참고하여 자유롭게 기록하세요.
                    - 두 번의 토론을 통해 새롭게 알게 된 점은 무엇인가?
                    - ChatGPT의 반박 중 설득력이 있었다고 느낀 부분은 무엇인가?
                    - 내 주장이나 근거에서 잘 대응했다고 느낀 부분은 무엇인가?
                    - 내 주장이나 근거에서 보완이 필요하다고 느낀 점은 무엇인가?
                    - 두 번의 토론을 비교했을 때, 논증 방식이나 사고 과정에서 성장했다고 느낀 점은 무엇인가?
                    - 추가적으로 개선하고 싶은 점은 무엇인가?
                  </p>
            </div>
          </div>
          <div class="prewriting-preview-block" id="stage5SummaryBlock">
                <strong>4-1차시 토론 요약</strong>
                <div id="stage5TranscriptSummary" class="text-block">4-1 토론 기록을 불러오는 중입니다. (추후 연동)</div>
              </div>
              <div class="button-row">
                <button id="btnStage5MemoSave" class="secondary" type="button" disabled>4차시-2 메모 저장</button>
              </div>
            </section>
          </div>

          <div class="right-column">
            <section id="rightStage2" class="right-panel">
              <div class="panel-header">
                <h2 id="aiStageTitle">ChatGPT 모의 토론 (gpt-4.1-mini)</h2>
                <span id="aiStageSubtitle" class="panel-subtext">찬·반 입장으로 질문하며 논거를 점검하세요. 정답 생성 대신 토론 연습에 집중합니다.</span>
              </div>
              <div class="chat-log" id="aiChatLog"></div>
              <div id="aiChatLoader" class="spinner"><span>AI 응답 생성 중...</span></div>
              <div class="chat-input">
                <textarea id="aiInput" placeholder="AI와 토론을 진행하세요." disabled></textarea>
                <div class="chat-actions">
                  <button id="btnAiSend" class="primary" type="button" disabled>전송</button>
          </div>
        </div>
            </section>

            <!-- rightStage3 (동료 채팅) 미사용 -->

            <section id="rightStage4" class="right-panel">
              <div class="panel-header">
                <h2 id="finalStageTitle">ChatGPT와 토론</h2>
                <span id="finalStageSubtitle" class="panel-subtext">
                  이제 ChatGPT는 당신의 입장과 반대되는 관점을 가진 토론 상대자로 설정됩니다.<br/>
                  당신이 반대 입장이므로, ChatGPT는 찬성 입장에서 토론합니다.<br/>
                  ChatGPT의 질문과 반박에 대해 주장–근거–재반박의 구조를 의식하며 충분히 토론을 진행해 보세요.
                </span>
              </div>
              <div class="chat-log" id="finalChatLog"></div>
              <div id="finalChatLoader" class="spinner"><span>AI 응답 생성 중...</span></div>
              <div class="chat-input">
                <textarea id="finalChatInput" placeholder="질문하거나 토론을 이어가세요." disabled></textarea>
                <div class="chat-actions">
                  <button id="btnFinalChatSend" class="primary" type="button" disabled>전송</button>
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(){
        'use strict';

        const APP_CONFIG = window.APP_CONFIG || { apiBaseUrl: '/api', apiKey: '' };
        const TYPE_KEYS = { TYPE_A: 'TYPE_A' };
        const DEFAULT_TYPE = TYPE_KEYS.TYPE_A;
        const TYPE_CONFIGS = {
          [TYPE_KEYS.TYPE_A]: {
            id: TYPE_KEYS.TYPE_A,
            label: 'Type A',
            description: '2차시~5차시 구성 (AI/동료 토론 통합)',
            group: 'A',
            aiStages: [1, 2, 3, 4, 5],
            peerStages: [],
            stepTemplate: [
              { badge: '1', stage: 1 },
              { badge: '2', stage: 2 },
              { badge: '3', stage: 3 },
              { badge: '4', stage: 4 },
              { badge: '5', stage: 5 },
            ],
          },
        };
        const DEFAULT_STAGE_LABELS = [
          { name: '2차시', headline: '토론 관련 발문', description: '논제 이해를 위해 핵심 발문을 확인하세요. 필요 시 교사가 제시합니다.' },
          { name: '3차시-1', headline: '토론 관련 발문', description: '토론 관련 발문을 바탕으로 쟁점과 논거를 정리하세요.' },
          {
            name: '3차시-2',
            headline: '토론 성찰',
            description:
              '토론을 통해 느낀 점과 보완할 점에 대해 자유롭게 성찰한 뒤 작성하세요.\n성찰한 내용을 바탕으로 자신의 생각을 정리해보세요. \n아래 항목을 참고하여 자유롭게 기록하세요.\n- 토론을 통해 새롭게 알게 된 점은 무엇인가?\n- ChatGPT의 반박 중 설득력이 있었다고 느낀 부분은 무엇인가?\n- 내 주장이나 근거에서 잘 대응했다고 느낀 부분은 무엇인가?\n- 내 주장이나 근거에서 보완이 필요하다고 느낀 점은 무엇인가?\n- 논증 방식이나 사고 과정에서 성장했다고 느낀 점은 무엇인가?\n- 다음 토론에서 개선하고 싶은 점은 무엇인가?'
          },
          {
            name: '4차시-1',
            headline: '토론 안내',
            description:
            '이제 ChatGPT는 다시 당신의 입장과 반대되는 관점을 가진 토론 상대자로 설정됩니다.\n\n이번 차시에서는 이전 차시와 ‘반대 입장’에서 토론을 진행합니다.\n당신이 반대 입장이므로, ChatGPT는 찬성 입장에서 토론합니다.\n\n즉, 이번 차시는 기존에 주장했던 입장을 그대로 반복하는 것이 아니라, 반대 관점을 이해하고 그 입장에서 논증하는 활동입니다.',
          },
          { name: '4차시-2', headline: '4-2차시 정리', description: '4-1차시 대화를 요약하고 추가 메모를 정리하세요.' },
        ];
        const DEFAULT_STAGE_PROMPTS = [
          {
            reference: '찬·반 논거를 조사하며 핵심 근거와 반론거리를 메모하세요. AI 웹검색을 활용해 다양한 출처를 탐색해 보세요.',
            aiPrompt: '당신은 학생의 토론 준비를 돕는 AI 웹연구 도우미입니다. 학생이 던지는 질문에 대해, 공정하게 찬성과 반대 측 근거를 모두 제시하세요. 각 bullet마다 신뢰할 만한 출처를 1~2개 제안하고, 출처는 반드시 마크다운 링크 형식([출처명](https://...))으로 표시하세요. 답변은 핵심 bullet 2~3개 중심으로, 쉬운 문장으로 작성합니다.',
          },
          {
            reference: 'ChatGPT와 모의 토론을 진행하며 찬성/반대 입장에서 나올 수 있는 반론을 미리 점검하세요.',
            aiPrompt: '당신은 학생과 토론을 진행하는 AI 멘토입니다. 학생의 주장에 근거를 요구하거나 빈틈을 짚어 주고, 설득력 있는 사례와 데이터로 논리를 강화하도록 유도하세요.',
          },
          {
            reference: '3-1차시 AI 대화를 다시 읽고 핵심 주장과 반론을 요약한 뒤, 평가 메모를 작성하세요.',
            aiPrompt: '당신은 토론 평가자입니다. 학생이 남긴 3-1차시 대화를 바탕으로 강점/보완점/추가 질문을 제안하세요. 구체적인 사례, 논거의 타당성, 반론 대비 등을 평가해 주세요.',
          },
          {
            reference: '4-1차시 토론 발문을 확인하고, AI와 심층 토론을 이어가세요. 주장·근거·반론을 명확하게 정리해 보세요.',
            aiPrompt: '당신은 학생의 최종 주장을 검토하는 AI 멘토입니다. 학생의 근거에 비판적 질문을 던지고, 더 정교한 논리를 완성하도록 도와주세요.',
          },
          { reference: '4-1차시 대화를 요약하고, 최종 주장을 정리하세요.', aiPrompt: '' },
        ];
        const DEFAULT_STAGE_LABELS_BY_TYPE = {
          [TYPE_KEYS.TYPE_A]: DEFAULT_STAGE_LABELS,
        };
        const DEFAULT_STAGE_PROMPTS_BY_TYPE = {
          [TYPE_KEYS.TYPE_A]: DEFAULT_STAGE_PROMPTS,
        };

        const PANEL_COPY_KEYS = [
          'prompt',
          'prewriting',
          'ai',
          'draft',
          'memo',
          'peer',
          'stage4',
          'final',
          'stage5',
        ];

        function createEmptyPanelCopy(){
          return PANEL_COPY_KEYS.reduce((acc, key) => {
            acc[key] = { title: '', subtitle: '' };
            return acc;
          }, {});
        }

        const DEFAULT_PANEL_COPY = createEmptyPanelCopy();
        DEFAULT_PANEL_COPY.ai = {
          title: '2차시 토론 논제 관련 ChatGPT 활용',
          subtitle:
            '토론을 준비하기 위해 관련된 내용을 ChatGPT에게 질문해 보세요.\n\n예를 들어 다음을 물어볼 수 있습니다:\n- 이 논제의 찬성/반대 대표 논거는 무엇인가요?\n- 구체적 논거는 어디에서 찾을 수 있나요?\n- 관련 통계·연구·사례에는 무엇이 있나요?\n- 반대 입장에서 가장 먼저 제기할 반박은?\n- 흔한 논리적 오류나 오해는 무엇인가요?\n\nChatGPT는 상호작용적 학습 도구이며, 본 시스템의 ChatGPT는 ChatGPT-5와 동일하게 동작합니다.',
        };
        const DEFAULT_PANEL_COPY_BY_TYPE = {
          [TYPE_KEYS.TYPE_A]: DEFAULT_PANEL_COPY,
        };

        const DEFAULT_UI_TEXT = {
          promptEmptyText: '토론 발문이 아직 등록되지 않았습니다.',
          draftPromptEmptyText: '관리자가 등록한 발문이 여기에 표시됩니다.',
          stage4PromptEmptyText: '관리자가 등록한 발문이 여기에 표시됩니다.',
          prewritingPlaceholder: '주장·근거, 출처, 의문점을 자유롭게 적어 두세요.',
          prewritingSaveButtonText: '',
          draftPlaceholder: '찬성/반대 주장, 근거, 추가 조사할 내용 등을 기록하세요.',
          draftSaveButtonText: '',
          notesPlaceholder: '3-1차시 토론을 다시 읽고, 궁금한 점이나 보완할 논거를 메모하세요.',
          aiInputPlaceholder: 'AI에게 토론 준비와 관련된 질문을 하세요.',
          aiSendButtonText: '전송',
          peerInputPlaceholder: '동료에게 메시지를 보내보세요.',
          peerSendButtonText: '전송',
          finalChatInputPlaceholder: '질문하거나 토론을 이어가세요.',
          finalChatSendButtonText: '전송',
          stage5MemoPlaceholder: '주장·근거, 출처, 의문점을 자유롭게 적어 두세요.',
          stage5MemoSaveButtonText: '4차시-2 메모 저장',
        };

        function buildAiGuideHtml(){
          const headline = '<strong><u>토론을 준비하기 위해 관련된 내용을 ChatGPT에게 질문해보세요.</u></strong>';
          const lead = '예를 들어 다음과 같은 질문을 할 수 있습니다.';
          const bullets = [
            '이 논제에 대한 찬성/반대 대표 논거에는 어떤 것들이 있나요?',
            '구체적인 논거는 어디에서 찾을 수 있나요?',
            '이 논제와 관련된 통계 자료나 연구 결과나 사례에는 어떤 것들이 있나요?',
            '반대 입장에서 가장 먼저 제기할 수 있는 반박은 무엇인가요?',
            '이 논제에서 흔히 나타나는 논리적 오류나 오해에는 어떤 것들이 있나요?',
          ];
          const list = `<ul style="margin:6px 0 0 18px; padding-left:0; line-height:1.55;">${bullets
            .map((item) => `<li style="list-style: disc; margin-left:0;">${item}</li>`)
            .join('')}</ul>`;
          const tail =
            'ChatGPT는 여러분의 토론 준비를 돕는 상호작용적 학습 도구가 될 수 있습니다. 본 시스템의 ChatGPT는 ChatGPT-5와 동일한 방식으로 작동합니다';
          return [headline, lead, list, tail].join('<br/>');
        }

        function buildPrewritingGuideHtml(){
          const headline = '<strong><u>토론을 준비하기 위해 논제와 관련된 정보를 조사하고 정리해 보세요.</u></strong>';
          const lead =
            '인터넷 검색, 뉴스 기사, 보고서, 오른쪽 창에 있는 ChatGPT 등을 활용하여 논제에 대한 다양한 관점과 자료를 탐색할 수 있습니다. 아래 항목을 참고하여 자유롭게 기록하세요.';
          const bullets = [
            '자신의 주장(찬성 또는 반대)',
            '주장을 뒷받침하는 근거 (사례, 통계, 논리 등)',
            '참고한 출처 (기사 제목, 기관명 등 간단히)',
            '조사 과정에서 생긴 의문점이나 반박 가능성',
          ];
          const list = `<ul style="margin:6px 0 0 18px; padding-left:0; line-height:1.55;">${bullets
            .map((item) => `<li style="list-style: disc; margin-left:0;">${item}</li>`)
            .join('')}</ul>`;
          const tail = '이 메모는 이후 ChatGPT과의 토론 및 성찰 활동시 자료로 활용할 예정입니다.';
          return [headline, lead, list, tail].join('<br/>');
        }

        function normalizeApiBaseUrl(path){
          if (!path) return `${window.location.origin}/api/`;
          const trimmed = String(path).trim();
          if (/^https?:\/\//i.test(trimmed)) {
            return trimmed.endsWith('/') ? trimmed : `${trimmed}/`;
          }
          const prefixed = trimmed.startsWith('/') ? trimmed : `/${trimmed}`;
          const combined = `${window.location.origin}${prefixed}`;
          return combined.endsWith('/') ? combined : `${combined}/`;
        }

        function createBackendClient(config){
          const baseUrl = normalizeApiBaseUrl(config.apiBaseUrl || '/api');
          const apiKey = config.apiKey || '';

          async function request(method, path, options){
            const opts = options || {};
            const url = new URL(path, baseUrl);
            if (opts.searchParams){
              Object.entries(opts.searchParams).forEach(function([key, value]){
                if (value === undefined || value === null || value === '') return;
                url.searchParams.set(key, value);
              });
            }
            const headers = { 'Content-Type': 'application/json' };
            if (apiKey) headers['x-api-key'] = apiKey;
            const fetchOptions = { method: method.toUpperCase(), headers };
            if (opts.body && fetchOptions.method !== 'GET') {
              fetchOptions.body = JSON.stringify(opts.body);
            }
            const response = await fetch(url.toString(), fetchOptions);
            if (response.status === 204) return null;
            const text = await response.text();
            let payload = null;
            if (text) {
              try {
                payload = JSON.parse(text);
              } catch (err) {
                console.error('서버 응답 파싱 실패', err, text);
                throw new Error('서버 응답을 읽을 수 없습니다.');
              }
            }
            if (!response.ok) {
              const message = (payload && (payload.error || payload.message)) || response.statusText;
              const error = new Error(message || '요청에 실패했습니다.');
              error.status = response.status;
              error.details = payload;
              throw error;
            }
            return payload;
          }

          return {
            isReady: true,
            getServerDiag: function(){ return request('GET', 'server/diag'); },
            getPublicSettings: function(){ return request('GET', 'public-settings'); },
            startSession: function(group, studentId, studentName){
              return request('POST', 'session/start', { body: { group, studentId, studentName } });
            },
            getSessionState: function(sessionKey){
              return request('GET', `session/${encodeURIComponent(sessionKey)}`);
            },
            submitPrewriting: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/prewriting`, { body: { text } });
            },
            savePostDraft: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/draft`, { body: { text } });
            },
            savePeerNotes: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/notes`, { body: { text } });
            },
            submitFinalWriting: function(sessionKey, text){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/final`, { body: { text } });
            },
            advanceToPeerStage: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/advance`);
            },
            advanceToFinalStage: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/advance-final`);
            },
            jumpToStage: function(sessionKey, stage, options){
              const payload = Object.assign({ stage }, options || {});
              return request('POST', `session/${encodeURIComponent(sessionKey)}/jump`, { body: payload });
            },
            regressStage: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/regress`);
            },
            touchPresence: function(sessionKey){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/presence/touch`);
            },
            postPresenceLeave: function(sessionKey, userId, userName){
              return request('POST', `session/${encodeURIComponent(sessionKey)}/presence/leave`, { body: { userId, userName } });
            },
            getMessages: function(sessionId, sinceTs, channel){
              return request('GET', `chat/${encodeURIComponent(channel)}/messages`, { searchParams: { sessionId, since: sinceTs } });
            },
            postMessage: function(sessionId, group, userId, userName, role, text, metadata){
              const channel = (metadata && metadata.channel) || 'ai-feedback';
              return request('POST', `chat/${encodeURIComponent(channel)}/send`, {
                body: { sessionId, group, userId, userName, role, text, metadata }
              });
            },
            requestAiIfNeeded: function(sessionId, group, userMessage, context, metadata){
              return request('POST', 'chat/ai/respond', { body: { sessionId, group, userMessage, context, metadata } });
            },
            lookupDictionary: function(query){
              return request('GET', 'dictionary', { searchParams: { q: query } });
            }
          };
        }

        function createRunner(api, handlers){
          const currentHandlers = handlers || {};
          return new Proxy({}, {
            get: function(_target, prop){
              if (prop === 'withSuccessHandler') {
                return function(fn){ return createRunner(api, Object.assign({}, currentHandlers, { success: fn })); };
              }
              if (prop === 'withFailureHandler') {
                return function(fn){ return createRunner(api, Object.assign({}, currentHandlers, { failure: fn })); };
              }
              if (typeof api[prop] === 'function') {
                return function(){
                  const args = Array.prototype.slice.call(arguments);
                  return api[prop].apply(api, args)
                    .then(function(result){
                      if (typeof currentHandlers.success === 'function') currentHandlers.success(result);
                      return result;
                    })
                    .catch(function(error){
                      if (typeof currentHandlers.failure === 'function') {
                        currentHandlers.failure(error);
                        return;
                      }
                      console.error(error);
                    });
                };
              }
              return undefined;
            }
          });
        }

        function createGoogleScriptRunShim(api){
          return createRunner(api, {});
        }

        const backend = createBackendClient(APP_CONFIG);
        const google = window.google = window.google || {};
        google.script = google.script || {};
        google.script.run = createGoogleScriptRunShim(backend);
        const hasGas = Boolean(backend && backend.isReady);

        const DEFAULT_AI_AVATAR = '/chatgpt.png';

        const state = {
          typeMode: DEFAULT_TYPE,
          group: TYPE_CONFIGS[DEFAULT_TYPE].group,
          sessionKey: '',
          user: { id: '', name: '' },
          stage: 1,
          updatedAt: 0,
          stageChangePending: false,
          writing: {
            prewriting: { text: '', submittedAt: 0 },
            draft: { text: '', savedAt: 0 },
            notes: { text: '', updatedAt: 0 },
            final: { text: '', submittedAt: 0 }
          },
          steps: {},
          partner: null,
          presence: null,
          status: { message: '식별 번호와 이름을 입력하면 세션이 시작됩니다.', type: 'info' },
          aiChat: { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false, awaitingResponse: false, welcomeShown: false },
          peerChat: { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false },
          aiStageLogs: {},
          aiTranscriptKeys: {},
          currentAiStage: 0,
          timers: { ai: null, peer: null, state: null, presence: null },
          refreshingState: false,
          dictionaryHistory: [],
          localPrewritingDraft: '',
          localFinalDraft: '',
          localDraftBuffer: '',
          localStage3Memo: '',
          localStage5Memo: '',
          aiAvatarUrl: DEFAULT_AI_AVATAR
        };

        const $ = (id) => document.getElementById(id);
        const publicConfig = {
          aiAvatarUrl: DEFAULT_AI_AVATAR,
          promptContent: '',
          uiText: { ...DEFAULT_UI_TEXT },
          stageLabelsByType: {
            [TYPE_KEYS.TYPE_A]: DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A].map((label) => ({ ...label })),
          },
          stagePromptsByType: {
            [TYPE_KEYS.TYPE_A]: DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A].map((prompt) => ({ ...prompt })),
          },
          panelCopyByType: {
            [TYPE_KEYS.TYPE_A]: clonePanelCopyDefaults(TYPE_KEYS.TYPE_A),
          },
        };

        function normalizeUiText(incoming, fallback) {
          const base = fallback && typeof fallback === 'object' ? fallback : DEFAULT_UI_TEXT;
          const src = incoming && typeof incoming === 'object' ? incoming : {};
          const out = { ...DEFAULT_UI_TEXT, ...base };
          Object.keys(out).forEach(function(key){
            if (Object.prototype.hasOwnProperty.call(src, key) && typeof src[key] === 'string') {
              out[key] = src[key];
            }
          });
          return out;
        }

        function normalizeStageLabels(list, fallbackList){
          const baseList =
            (Array.isArray(fallbackList) && fallbackList.length ? fallbackList : DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A]) ||
            [];
          return baseList.map((label, idx) => {
            const incoming = Array.isArray(list) && list[idx] ? list[idx] : {};
            return {
              name: typeof incoming.name === 'string' ? incoming.name.trim() || label.name : label.name,
              headline: typeof incoming.headline === 'string' ? incoming.headline.trim() || label.headline : label.headline,
              description:
                typeof incoming.description === 'string'
                  ? incoming.description.trim() || label.description
                  : label.description,
            };
          });
        }

        function getStageLabelsForType(typeKey){
          const key = TYPE_CONFIGS[typeKey] ? typeKey : TYPE_KEYS.TYPE_A;
          const stored = publicConfig.stageLabelsByType[key];
          if (Array.isArray(stored) && stored.length) return stored;
          return DEFAULT_STAGE_LABELS_BY_TYPE[key] || DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A];
        }

        function getStageLabel(stageNumber){
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const labels = getStageLabelsForType(typeKey);
          const index = Math.max(0, Math.min(labels.length - 1, Number(stageNumber || 1) - 1));
          return labels[index] || labels[0];
        }

        function getStageDisplayName(stageNumber){
          const label = getStageLabel(stageNumber);
          if (label && label.name) return label.name;
          return `${stageNumber}단계`;
        }

        function normalizeStagePrompts(list, fallbackList){
          const baseList =
            (Array.isArray(fallbackList) && fallbackList.length ? fallbackList : DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A]) ||
            [];
          return baseList.map((prompt, idx) => {
            const incoming = Array.isArray(list) && list[idx] ? list[idx] : {};
            return {
              reference:
                typeof incoming.reference === 'string'
                  ? incoming.reference
                  : typeof prompt.reference === 'string'
                    ? prompt.reference
                    : '',
              aiPrompt:
                typeof incoming.aiPrompt === 'string'
                  ? incoming.aiPrompt
                  : typeof prompt.aiPrompt === 'string'
                    ? prompt.aiPrompt
                    : '',
            };
          });
        }

        function clonePanelCopyDefaults(typeKey){
          const source = DEFAULT_PANEL_COPY_BY_TYPE[typeKey] || {};
          return PANEL_COPY_KEYS.reduce((acc, key) => {
            const entry = source[key] || { title: '', subtitle: '' };
            acc[key] = { title: entry.title || '', subtitle: entry.subtitle || '' };
            return acc;
          }, {});
        }

        function normalizePanelCopy(map, fallback){
          return PANEL_COPY_KEYS.reduce((acc, key) => {
            const incoming = map && typeof map[key] === 'object' ? map[key] : null;
            const fallbackEntry =
              (fallback && typeof fallback[key] === 'object' && fallback[key]) || { title: '', subtitle: '' };
            const incomingTitle =
              typeof incoming?.title === 'string' && incoming.title.trim() !== '' ? incoming.title : null;
            const incomingSubtitle =
              typeof incoming?.subtitle === 'string' && incoming.subtitle.trim() !== '' ? incoming.subtitle : null;
            acc[key] = {
              title:
                incomingTitle !== null
                  ? incomingTitle
                  : typeof fallbackEntry.title === 'string'
                    ? fallbackEntry.title
                    : '',
              subtitle:
                incomingSubtitle !== null
                  ? incomingSubtitle
                  : typeof fallbackEntry.subtitle === 'string'
                    ? fallbackEntry.subtitle
                    : '',
            };
            return acc;
          }, {});
        }

        function getPanelCopyEntry(panelKey){
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const store = publicConfig.panelCopyByType[typeKey] || {};
          const entry = store[panelKey];
          const fallback = (DEFAULT_PANEL_COPY_BY_TYPE[typeKey] || {})[panelKey] || { title: '', subtitle: '' };
          return {
            title: typeof entry?.title === 'string' ? entry.title : fallback.title || '',
            subtitle: typeof entry?.subtitle === 'string' ? entry.subtitle : fallback.subtitle || '',
          };
        }

        function getStagePromptsForType(typeKey){
          const key = TYPE_CONFIGS[typeKey] ? typeKey : TYPE_KEYS.TYPE_A;
          const stored = publicConfig.stagePromptsByType[key];
          if (Array.isArray(stored) && stored.length) return stored;
          return DEFAULT_STAGE_PROMPTS_BY_TYPE[key] || DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A];
        }

        function getStagePromptData(stageNumber){
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const prompts = getStagePromptsForType(typeKey);
          const index = Math.max(0, Math.min(prompts.length - 1, Number(stageNumber || 1) - 1));
          return prompts[index] || prompts[0];
        }

        function setRichText(id, text, fallback){
          const el = $(id);
          if (!el) return;
          const content = String(text || '').trim();
          if (!content) {
            el.innerHTML = fallback || '';
            return;
          }
          el.innerHTML = escapeHtml(content).replace(/\n/g, '<br/>');
        }

        function applyUiText(){
          const ui = publicConfig.uiText || DEFAULT_UI_TEXT;
          const setPlaceholder = (id, text) => {
            const el = $(id);
            if (!el) return;
            if (typeof text === 'string' && text) el.setAttribute('placeholder', text);
          };
          setPlaceholder('prewritingInput', ui.prewritingPlaceholder || '');
          setPlaceholder('draftInput', ui.draftPlaceholder || '');
          setPlaceholder('notesInput', ui.notesPlaceholder || '');
          setPlaceholder('aiInput', ui.aiInputPlaceholder || '');
          setPlaceholder('finalChatInput', ui.finalChatInputPlaceholder || '');
          setPlaceholder('stage5MemoInput', ui.stage5MemoPlaceholder || '');

          // 버튼 문구(비어있으면 기존 기본값 유지)
          if (ui.prewritingSaveButtonText) setText('btnPreSubmit', ui.prewritingSaveButtonText);
          if (ui.draftSaveButtonText) setText('btnSaveDraft', ui.draftSaveButtonText);
          if (ui.aiSendButtonText) setText('btnAiSend', ui.aiSendButtonText);
          if (ui.peerSendButtonText) setText('btnPeerSend', ui.peerSendButtonText);
          if (ui.finalChatSendButtonText) setText('btnFinalChatSend', ui.finalChatSendButtonText);
          if (ui.stage5MemoSaveButtonText) setText('btnStage5MemoSave', ui.stage5MemoSaveButtonText);
        }

        function getTypeConfig(typeKey){
          return TYPE_CONFIGS[typeKey] || TYPE_CONFIGS[TYPE_KEYS.TYPE_A];
        }

        function mapGroupToTypeKey(group){
          return TYPE_KEYS.TYPE_A;
        }

        function setTypeMode(typeKey, options){
          const opts = options || {};
          const config = getTypeConfig(typeKey);
          const prevType = state.typeMode;
          state.typeMode = config.id;
          state.group = config.group;
          if (!opts.silent || !prevType || prevType !== config.id) {
            updateSelectedTypeLabel();
          }
          buildStepIndicator();
          if (opts.skipWorkspace) {
            updateStepIndicator();
            return;
          }
          renderWorkspace();
        }

        function updateSelectedTypeLabel(){
          const label = $('selectedTypeLabel');
          if (!label) return;
          const config = getTypeConfig(state.typeMode);
          label.textContent = config.label || 'Type A';
        }

        function showLoginCard(){
          const loginCard = $('loginCard');
          if (loginCard) {
            loginCard.style.display = 'block';
            const studentIdInput = $('studentIdInput');
            if (studentIdInput) studentIdInput.focus();
          }
        }

        function setText(id, text){
          const el = $(id);
          if (!el) return;
          el.textContent = text || '';
        }

        function init(){
          const loginForm = $('loginForm');
          if (loginForm) loginForm.addEventListener('submit', onLoginSubmit);
          const restartBtn = $('btnRestart');
          if (restartBtn) restartBtn.addEventListener('click', function(){
            if (state.sessionKey && !confirm('현재 세션을 종료하고 처음 화면으로 돌아가시겠습니까?')) return;
            resetToLogin(true);
          });

          const prewritingInput = $('prewritingInput');
          if (prewritingInput) prewritingInput.addEventListener('input', function(){
            const btn = $('btnPreSubmit');
            if (!btn) return;
            const isStageActive = Number(state.stage || 1) === 1;
            btn.disabled = !isStageActive || !this.value.trim();
            state.localPrewritingDraft = this.value;
          });

          const draftInput = $('draftInput');
          if (draftInput) draftInput.addEventListener('input', function(){
            const btn = $('btnSaveDraft');
            if (!btn) return;
            const stage = Number(state.stage || 1);
            const editable = stage === 2 && !state.writing.final.submittedAt;
            state.localDraftBuffer = this.value;
            btn.disabled = !editable || !this.value.trim();
          });

          const draftBackBtn = $('btnDraftBack');
          if (draftBackBtn) draftBackBtn.addEventListener('click', onGoToPreviousStage);

          const notesInput = $('notesInput');
          if (notesInput) notesInput.addEventListener('input', function(){
            const btn = $('btnNotesSave');
            if (!btn) return;
            const stage = Number(state.stage || 1);
            const group = (state.group || '').toUpperCase();
            const enabled = (stage === 3 && group === 'A') && !state.writing.final.submittedAt;
            state.localStage3Memo = this.value;
            btn.disabled = !enabled || !this.value.trim();
          });

          const stage3BackBtn = $('btnStage3Back');
          if (stage3BackBtn) stage3BackBtn.addEventListener('click', onGoToPreviousStage);

          const finalInput = $('finalInput');
          if (finalInput) finalInput.addEventListener('input', function(){
            state.localFinalDraft = this.value;
            const btn = $('btnFinalSubmit');
            if (!btn) return;
            const canEdit = Number(state.stage || 1) === 4 && !(state.writing.final && Number(state.writing.final.submittedAt || 0) > 0);
            btn.disabled = !canEdit || !this.value.trim();
          });

          const finalBackBtn = $('btnFinalBack');
          if (finalBackBtn) finalBackBtn.addEventListener('click', onGoToPreviousStage);

          const dictQuery = $('dictQuery');
          if (dictQuery) dictQuery.addEventListener('keydown', function(e){ if (e.key === 'Enter'){ e.preventDefault(); onDictionarySearch(); } });
          const dictBtn = $('btnDictSearch');
          if (dictBtn) dictBtn.addEventListener('click', onDictionarySearch);

          const aiSendBtn = $('btnAiSend');
          if (aiSendBtn) aiSendBtn.addEventListener('click', sendAiMessage);
          const aiInput = $('aiInput');
          if (aiInput) aiInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendAiMessage(); } });
          const finalSendBtn = $('btnFinalChatSend');
          if (finalSendBtn) finalSendBtn.addEventListener('click', sendAiMessage);
          const finalChatInput = $('finalChatInput');
          if (finalChatInput) finalChatInput.addEventListener('keydown', function(e){ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendAiMessage(); } });

          const stage5MemoInput = $('stage5MemoInput');
          if (stage5MemoInput) stage5MemoInput.addEventListener('input', function(){
            const btn = $('btnStage5MemoSave');
            if (!btn) return;
            btn.disabled = !this.value.trim();
          });
          const stage5MemoSave = $('btnStage5MemoSave');
          if (stage5MemoSave) stage5MemoSave.addEventListener('click', onSaveStage5Memo);

          const preBtn = $('btnPreSubmit');
          if (preBtn) preBtn.addEventListener('click', onSubmitPrewriting);
          const draftSaveBtn = $('btnSaveDraft');
          if (draftSaveBtn) draftSaveBtn.addEventListener('click', onSaveDraft);
          const toPeerBtn = $('btnToPeer');
          if (toPeerBtn) toPeerBtn.addEventListener('click', onAdvanceToPeerStage);
          const notesSaveBtn = $('btnNotesSave');
          if (notesSaveBtn) notesSaveBtn.addEventListener('click', onSavePeerNotes);
          const finalBtn = $('btnFinalSubmit');
          if (finalBtn) finalBtn.addEventListener('click', onSubmitFinalWriting);

          resetToLogin();

          loadPublicSettings();
          buildStepIndicator();
          renderWorkspace();
          updateSelectedTypeLabel();
          setStatus('식별 번호와 이름을 입력하세요.', 'info');

          if (hasGas) {
            try {
        google.script.run.withSuccessHandler(function(info){
                if (!info) return;
                if (!info.teacherSheetId) {
                  $('loginMessage').textContent = '⚠️ 관리자: 교사 시트 ID가 설정되지 않았습니다.';
                }
        }).getServerDiag();
            } catch (e) { console.error(e); }
          }

          window.addEventListener('beforeunload', function(){
            if (!hasGas) return;
            try {
              if (state.sessionKey && state.user.id) {
                google.script.run.postPresenceLeave(state.sessionKey, state.user.id, state.user.name);
              }
            } catch (e) { console.error(e); }
          });
        }

        function resetState(options){
          const opts = options || {};
          if (opts.typeMode) {
            state.typeMode = opts.typeMode;
          }
          const config = getTypeConfig(state.typeMode);
          state.group = config.group;
          state.sessionKey = '';
          state.user = { id: '', name: '' };
          state.stage = 1;
          state.updatedAt = 0;
          state.stageChangePending = false;
          state.writing = {
            prewriting: { text: '', submittedAt: 0 },
            draft: { text: '', savedAt: 0 },
            notes: { text: '', updatedAt: 0 },
            final: { text: '', submittedAt: 0 }
          };
          state.steps = {};
          state.partner = null;
          state.presence = null;
          state.status = { message: '식별 번호와 이름을 입력하면 세션이 시작됩니다.', type: 'info' };
          state.aiChat = { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false, awaitingResponse: false, welcomeShown: false };
          state.peerChat = { sessionId: '', lastTs: 0, rendered: {}, pending: {}, fetching: false };
          state.dictionaryHistory = [];
          state.refreshingState = false;
          clearChatLog('ai');
          clearChatLog('peer');
          state.localPrewritingDraft = '';
          state.localFinalDraft = '';
          state.localDraftBuffer = '';
          state.localStage3Memo = '';
          state.localStage5Memo = '';
          state.aiStageLogs = {};
          state.aiTranscriptKeys = {};
          state.currentAiStage = 0;
          state.aiAvatarUrl = publicConfig.aiAvatarUrl || DEFAULT_AI_AVATAR;
        }

        function resetToLogin(clearInput){
          clearAllTimers();
          resetState({ typeMode: DEFAULT_TYPE });
          $('workspace').style.display = 'none';
          showLoginCard();
          if (clearInput) {
            $('studentIdInput').value = '';
            $('studentNameInput').value = '';
          }
          buildStepIndicator();
          updateSelectedTypeLabel();
          renderUserInfo();
          setStatus('식별 번호와 이름을 입력하세요.', 'info');
        }

        function onLoginSubmit(e){
          e.preventDefault();
          if (!hasGas) {
            handleError('백엔드 서비스가 연결되지 않았습니다.');
            return;
          }
          const sid = $('studentIdInput').value.trim();
          const name = $('studentNameInput').value.trim();
          if (!sid || !name) { setStatus('식별 번호와 이름을 모두 입력하세요.', 'warn'); return; }
          $('loginSubmit').disabled = true;
          $('loginSubmit').textContent = '진행 중...';
          setStatus('세션을 초기화하는 중입니다...', 'info');
        google.script.run.withSuccessHandler(function(res){
            $('loginSubmit').disabled = false;
            $('loginSubmit').textContent = '실험 시작';
            onSessionStart(res);
            const stage1Name = getStageDisplayName(1);
            setStatus(`세션이 시작되었습니다. ${stage1Name}을 진행하세요.`, 'success');
          }).withFailureHandler(function(err){
            $('loginSubmit').disabled = false;
            $('loginSubmit').textContent = '실험 시작';
            handleError(err);
          }).startSession(state.group, sid, name);
        }

        function onSessionStart(res){
          if (!res) { handleError('세션 정보를 불러오지 못했습니다.'); return; }
          const resolvedGroup = (res.mode || res.group || state.group || getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A).group || 'A').toUpperCase();
          const resolvedType = mapGroupToTypeKey(resolvedGroup);
          setTypeMode(resolvedType, { skipWorkspace: true });
          state.group = resolvedGroup;
          state.user = { id: (res.you && res.you.id) || '', name: (res.you && res.you.name) || '' };
          state.sessionKey = res.sessionKey || '';
          state.aiChat = { sessionId: res.aiSessionId || '', lastTs: 0, rendered: {}, pending: {}, fetching: false, awaitingResponse: false, welcomeShown: false };
          state.peerChat = { sessionId: res.peerSessionId || '', lastTs: 0, rendered: {}, pending: {}, fetching: false };
          state.aiAvatarUrl = publicConfig.aiAvatarUrl || state.aiAvatarUrl || DEFAULT_AI_AVATAR;
          state.localPrewritingDraft = '';
          state.stageChangePending = false;
          updateSelectedTypeLabel();
          $('loginCard').style.display = 'none';
          $('workspace').style.display = 'flex';
          const sessionState = {
            sessionKey: res.sessionKey,
            stage: res.stage,
            updatedAt: Number(res.updatedAt || 0),
            prewriting: res.writing && res.writing.prewriting ? res.writing.prewriting : res.prewriting,
            draft: res.writing && res.writing.draft ? res.writing.draft : res.draft,
            notes: res.writing && res.writing.notes ? res.writing.notes : res.notes,
            final: res.writing && res.writing.final ? res.writing.final : res.final,
            steps: res.steps,
            partner: res.partner,
            presence: res.presence,
            aiSessionId: res.aiSessionId,
            peerSessionId: res.peerSessionId
          };
          syncSessionState(sessionState);
          ensurePollers();
          sendPresencePing();
          pollAiMessages();
          pollPeerMessages();
        }

        function syncSessionState(data){
          if (!data) return;
          const currentUpdatedAt = Number(state.updatedAt || 0);
          const incomingUpdatedAt = Number(data.updatedAt || 0);
          if (incomingUpdatedAt && currentUpdatedAt && incomingUpdatedAt < currentUpdatedAt) {
            console.warn('Stale session state ignored', data);
            return;
          }
          if (incomingUpdatedAt) {
            state.updatedAt = incomingUpdatedAt;
          }
          const prevStage = Number(state.stage || 1);
          if (data.sessionKey) state.sessionKey = data.sessionKey;
          if (data.aiSessionId) {
            const prevAiSessionId = state.aiChat.sessionId;
            state.aiChat.sessionId = data.aiSessionId;
            if (prevAiSessionId && prevAiSessionId !== data.aiSessionId) {
              clearChatLog('ai');
              state.aiChat.welcomeShown = false;
            }
          }
          const prevPeerSessionId = state.peerChat.sessionId;
          if (data.peerSessionId !== undefined && data.peerSessionId !== null) {
            state.peerChat.sessionId = String(data.peerSessionId).trim();
          }
          if (prevPeerSessionId && state.peerChat.sessionId && prevPeerSessionId !== state.peerChat.sessionId) {
            clearChatLog('peer');
            state.peerChat.lastTs = 0;
          }
          var incomingStage = Number(data.stage || 0);
          if (incomingStage) {
            state.stage = incomingStage;
          }
          if (!state.stage || state.stage < 1) state.stage = 1;
          const incomingWriting = data.writing || {};
          state.writing.prewriting = incomingWriting.prewriting || data.prewriting || state.writing.prewriting;
          state.writing.draft = incomingWriting.draft || data.draft || state.writing.draft;
          state.writing.notes = incomingWriting.notes || data.notes || state.writing.notes;
          state.writing.final = incomingWriting.final || data.final || state.writing.final;
          if (Number(state.stage || 1) <= 1 && !(state.writing.prewriting && Number(state.writing.prewriting.submittedAt || 0))) {
            if (typeof state.localPrewritingDraft !== 'string' || !state.localPrewritingDraft) {
              state.localPrewritingDraft = (state.writing.prewriting && state.writing.prewriting.text) || state.localPrewritingDraft || '';
            }
          } else {
            state.localPrewritingDraft = '';
          }
          state.steps = data.steps || state.steps;
          state.partner = data.partner || null;
          state.presence = data.presence || null;

          const currentStage = Number(state.stage || 1);
          if (currentStage === 4) {
            if (state.writing.final && Number(state.writing.final.submittedAt || 0) > 0) {
              state.localFinalDraft = state.writing.final.text || '';
            } else if (prevStage !== 4 && !state.localFinalDraft) {
              state.localFinalDraft = (state.writing.final && state.writing.final.text) || (state.writing.prewriting && state.writing.prewriting.text) || '';
            }
          } else if (currentStage < 4) {
            state.localFinalDraft = '';
          }

          const group = (state.group || '').toUpperCase();
          if (state.writing.draft && state.writing.draft.text) {
            if (currentStage !== 2 || !state.localDraftBuffer || state.localDraftBuffer === state.writing.draft.text) {
              state.localDraftBuffer = state.writing.draft.text;
            }
          } else if (currentStage !== 2) {
            state.localDraftBuffer = '';
          }

          if (state.writing.notes && state.writing.notes.text) {
            if (currentStage !== 3 || !state.localStage3Memo || state.localStage3Memo === state.writing.notes.text) {
              state.localStage3Memo = state.writing.notes.text;
            }
          } else if (currentStage !== 3) {
            state.localStage3Memo = '';
          }

          renderWorkspace();
          ensurePollers();
        }

        function applyStageLabelsToPanels(){
          const combine = (label, fallback, options = {}) => {
            if (!label) return fallback;
            if (options.headlineOnly) return label.headline || label.name || fallback;
            if (label.headline && label.name) return `${label.name} · ${label.headline}`;
            return label.headline || label.name || fallback;
          };
          const stage1 = getStageLabel(1);
          if (stage1) {
            const promptCopy = getPanelCopyEntry('prompt');
            setText('promptStageTitle', promptCopy.title || combine(stage1, '2차시 · 토론 관련 발문'));
            const topicLine1 = '<strong><u>다음을 읽고, 토론 논제를 이해해 보세요.</u></strong>';
            const topicLine2 = '<strong><u>교육감 선거 선거권 연령을 16세로 하향하여야 한다.</u></strong>';
            const promptBase = promptCopy.subtitle || stage1.description || '논제 이해를 위해 핵심 발문을 확인하세요.';
            const promptSub = $('promptStageSubtitle');
            if (promptSub) promptSub.innerHTML = `${topicLine1}<br/>${topicLine2}`;
            const prewritingCopy = getPanelCopyEntry('prewriting');
            setText('prewritingTitle', prewritingCopy.title || combine(stage1, '2차시 · 메모장'));
            const prewritingInfo = $('prewritingInfo');
            if (prewritingInfo) prewritingInfo.innerHTML = buildPrewritingGuideHtml();
            const aiCopy = getPanelCopyEntry('ai');
            setText('aiStageTitle', aiCopy.title || stage1.headline || stage1.name || 'AI 피드백');
            const aiSubtitle = $('aiStageSubtitle');
            if (aiSubtitle) aiSubtitle.innerHTML = buildAiGuideHtml();
          }
          const stage2 = getStageLabel(2);
          if (stage2) {
            // 3차시-1 고정 안내 (관리자 설정 무시)
            setText('draftTitle', '3차시-1 ChatGPT와의 토론');
            const draftInfoEl = $('draftInfo');
            if (draftInfoEl) {
              const line1 = '이제 ChatGPT는 당신의 입장과 반대되는 관점을 가진 토론 상대로 설정됩니다.';
              const line2 = '<strong><u>당신이 찬성 입장이므로, ChatGPT는 반대 입장에서 토론합니다.</u></strong>';
              const line3 = 'ChatGPT의 질문과 반박에 대해 주장-근거-재반박의 구조를 의식하며 충분히 토론을 진행해 보세요.';
              const html = [line1, line2, line3].join('<br/>');
              draftInfoEl.innerHTML = html;
              draftInfoEl.dataset.baseHtml = html;
            }
            const transcriptHeading = $('stage3TranscriptHeading');
            if (transcriptHeading) {
              transcriptHeading.textContent = (stage2.name || '3-1차시') + ' 토론 기록';
            }
          }
          const stage3 = getStageLabel(3);
          if (stage3) {
            // 3차시-2 안내를 고정 문구로 지정 (관리자 설정 무시)
            setText('memoStage3Title', '3차시-2 · 토론 성찰');
            const memoInfoEl = $('memoStage3Info');
            if (memoInfoEl) {
              const headline = '<strong><u>토론을 통해 느낀 점과 보완할 점에 대해 자유롭게 성찰한 뒤 작성하세요. 아래 항목을 참고하세요.</u></strong>';
              const bullets = [
                '토론을 통해 새롭게 알게 된 점은 무엇인가?',
                'ChatGPT의 반박 중 설득력이 있었다고 느낀 부분은 무엇인가?',
                '내 주장이나 근거에서 잘 대응했다고 느낀 부분은 무엇인가?',
                '내 주장이나 근거에서 보완이 필요하다고 느낀 점은 무엇인가?',
                '논증 방식이나 사고 과정에서 성장했다고 느낀 점은 무엇인가?',
                '다음 토론에서 개선하고 싶은 점은 무엇인가?'
              ];
              const list = `<ul style="margin:8px 0 0 18px; padding-left:0; line-height:1.55;">${bullets.map((item) => `<li style="list-style: disc; margin-left:0;">${item}</li>`).join('')}</ul>`;
              const html = `${headline}${list}`;
              memoInfoEl.innerHTML = html;
              memoInfoEl.dataset.baseText = html;
            }
          }
          const stage4 = getStageLabel(4);
          if (stage4) {
            // 4차시-1 제목/설명을 고정 (관리자 설정 무시)
            setText('stage4Title', '4차시-1 · 토론 안내');
            const stage4Sub = $('stage4Subtitle');
            if (stage4Sub) {
              const line1 = '<strong><u>이번 차시에는, 반대의 입장에서 실제 토론에 집중해보세요.</u></strong>';
              const line2 = '2차시에 정리한 자료, 3차시 성찰메모를 바탕으로 자신의 주장을 논리적으로 설명하고, 반박에 대응해보세요.';
              stage4Sub.innerHTML = [line1, line2].join('<br/>');
            }

            const finalCopy = getPanelCopyEntry('final');
            setText('finalStageTitle', '4차시-1 · 토론 안내');
            const finalSub = $('finalStageSubtitle');
            if (finalSub) {
              // 우측 챗봇 헤더에는 간단 안내만 남겨 중복 표시를 피함
              finalSub.innerHTML = '';
            }
          }
          const stage5 = getStageLabel(5);
          if (stage5) {
            const stage5Copy = getPanelCopyEntry('stage5');
            setText('stage5Title', stage5Copy.title || combine(stage5, '5차시 · 정리'));
            setText(
              'stage5Subtitle',
              stage5Copy.subtitle || stage5.description || '4-1차시 대화를 요약해 확인하고, 추가로 메모하세요.'
            );
          }
        }

        function renderWorkspace(){
          applyStageLabelsToPanels();
          applyUiText();
          renderUserInfo();
          updateStepIndicator();
          updateStageVisibility();
          renderPrewritingPanel();
          renderDraftPanel();
          renderStage4DraftPanel();
          renderPeerPanel();
          renderStagePrompts();
          renderFinalPanel();
          renderStage5Panel();
          renderFinalChatPanel();
          renderRightPanels();
          renderPresence();
          renderDictionaryHistory();
          refreshChatControls();

          // AI/peer 채팅은 단계 전환 시 초기화
          const numericStage = Number(state.stage || 1);
          const aiStageActive = isAiChatStage(numericStage);
          if (!aiStageActive) {
            if (state.currentAiStage) {
              clearChatLog('ai', { keepLastTs: false });
              state.aiChat.welcomeShown = false;
            }
            state.currentAiStage = 0;
          } else if (state.currentAiStage !== numericStage) {
            clearChatLog('ai', { keepLastTs: false }); // 단계 전환 시 전체 기록을 다시 불러오도록 lastTs도 리셋
            state.aiChat.welcomeShown = false;
            state.currentAiStage = numericStage;
          }
          const peerStageActive = isPeerChatStage(numericStage);
          if (!peerStageActive) {
            clearChatLog('peer');
          }
        }


        function getPreviousStageNumber(){
          const current = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          if (current <= 1) return 1;
          if (current === 2) return 1;
          if (current === 3) return 2;
          if (current === 4) return group === 'C' ? 2 : 3;
          if (current >= 5) return 4;
          return Math.max(1, current - 1);
        }

        function updateStageVisibility(){
          const stage = Number(state.stage || 1);
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const showStage1 = stage === 1; // 2차시는 1단계에서만 입력/표시
          const showStage2 = stage === 2;
          const showStage3 = stage === 3;
          const showStage4 = stage === 4;
          const showStage5 = stage >= 5;
          setPanelVisibility('panelPrompt', showStage1);
          setPanelVisibility('panelPrewriting', showStage1 && typeKey === TYPE_KEYS.TYPE_A);
          setPanelVisibility('panelDraft', showStage2);
          setPanelVisibility('panelMemoStage3', showStage3);
          setPanelVisibility('panelFinalSummary', showStage4);
          setPanelVisibility('panelStage4Draft', showStage4);
          setPanelVisibility('panelStage5', showStage5);
        }

        function setPanelVisibility(id, visible){
          var el = $(id);
          if (!el) return;
          el.style.display = visible ? 'flex' : 'none';
        }

        function buildStepIndicator(){
          const container = $('stepIndicator');
          if (!container) return;
          container.innerHTML = '';
          const typeConfig = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const labels = getStageLabelsForType(state.typeMode || TYPE_KEYS.TYPE_A);
          const template = Array.isArray(typeConfig.stepTemplate) ? typeConfig.stepTemplate : [];
          template.forEach(function(entry){
            const item = document.createElement('div');
            item.className = 'step-item';
            item.dataset.step = entry.stage;
            if (entry.segment) item.dataset.segment = entry.segment;
            item.dataset.titleOverride = entry.titleOverride || '';
            const number = document.createElement('div');
            number.className = 'step-number';
            number.textContent = entry.badge || entry.stage;
            const info = document.createElement('div');
            info.className = 'step-info';
            const title = document.createElement('div');
            title.className = 'step-title';
            const labelIndex = Math.max(0, Math.min(labels.length - 1, Number(entry.stage || 1) - 1));
            const label = labels[labelIndex] || {};
            title.textContent = entry.titleOverride || label.name || `단계 ${entry.stage}`;
            const caption = document.createElement('div');
            caption.className = 'step-caption';
            caption.textContent = label.headline || label.description || '';
            info.appendChild(title);
            info.appendChild(caption);
            item.appendChild(number);
            item.appendChild(info);
            item.addEventListener('click', onStepIndicatorClick);
            container.appendChild(item);
          });
          updateStepIndicator();
        }

        function renderUserInfo(){
          const el = $('userInfo');
          if (!el) return;
          const config = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const typeLabel = config.label || 'Type A';
          if (state.sessionKey) {
            const userLabel = `${state.user.id || ''} ${state.user.name || ''}`.trim();
            el.textContent = userLabel ? `${typeLabel} · ${userLabel}` : typeLabel;
          } else {
            el.textContent = typeLabel;
          }
        }

        function updateStepIndicator(){
          const current = Number(state.stage || 1);
          document.querySelectorAll('#stepIndicator .step-item').forEach(function(item){
            const step = Number(item.dataset.step);
            item.classList.toggle('active', step === current);
            item.classList.toggle('completed', step < current);
            const canNavigate = step !== current && canSelectStage(step) && !state.stageChangePending && !state.sessionKey;
            item.classList.toggle('clickable', canNavigate);
            item.setAttribute('aria-disabled', canNavigate ? 'false' : 'true');
            item.style.cursor = canNavigate ? 'pointer' : '';
            const titleNode = item.querySelector('.step-title');
            const captionNode = item.querySelector('.step-caption');
            const label = getStageLabel(step);
            if (titleNode) {
              const override = item.dataset.titleOverride;
              titleNode.textContent = override || label?.name || `단계 ${step}`;
            }
            if (captionNode) {
              captionNode.textContent = label?.headline || label?.description || '';
            }
          });
        }

        function getHighestUnlockedStage(){
          let highest = Number(state.stage || 1) || 1;
          const steps = state.steps || {};
          
          // 1단계(사전 글쓰기)가 완료되면 이후 단계(2,3,4)를 모두 자유롭게 이동할 수 있도록 허용
          if (steps.prewriting && steps.prewriting.completed) {
            return 5;
          }
          
          const group = (state.group || '').toUpperCase();
          if (steps.prewriting && steps.prewriting.completed) {
            highest = Math.max(highest, 2);
          }
          if (group === 'A') {
            if (steps.draft && steps.draft.saved) {
              highest = Math.max(highest, 3);
            }
            const finalUnlocked = Number(state.stage || 1) >= 4 || (state.writing && state.writing.final && (state.writing.final.text || Number(state.writing.final.submittedAt || 0))) || (steps.final && steps.final.submitted);
            if (finalUnlocked) {
              highest = Math.max(highest, 4);
            }
          } else if (group === 'C') {
            const finalUnlocked = Number(state.stage || 1) >= 4 || (state.writing && state.writing.final && (state.writing.final.text || Number(state.writing.final.submittedAt || 0))) || (steps.final && steps.final.submitted);
            if (finalUnlocked) {
              highest = Math.max(highest, 4);
            }
          } else {
            if (Number(state.stage || 1) >= 4 || (steps.final && steps.final.submitted)) {
              highest = Math.max(highest, 4);
            }
          }
          if (Number(state.stage || 1) >= 5) {
            highest = Math.max(highest, 5);
          }
          return Math.max(1, Number(highest || 1));
        }

        function canSelectStage(step){
          const desired = Number(step || 0);
          if (!desired || desired < 1) return false;
          const typeKey = state.typeMode || TYPE_KEYS.TYPE_A;
          const typeConfig = getTypeConfig(typeKey);
          const template = Array.isArray(typeConfig.stepTemplate) ? typeConfig.stepTemplate : [];
          return template.some((entry) => Number(entry.stage) === desired);
        }

        function navigateToStage(targetStage){
          const target = Number(targetStage || 0);
          if (!target || target < 1) return;
          const current = Number(state.stage || 1);
          if (target === current) return;
          if (!canSelectStage(target)) {
            setStatus('해당 단계로 이동할 수 없습니다.', 'warn');
            return;
          }
          if (!hasGas) return;
          if (!state.sessionKey) { setStatus('세션이 활성화되지 않았습니다.', 'error'); return; }
          if (state.stageChangePending) return;
          state.stageChangePending = true;
          updateStepIndicator();
          const label = formatStageName(target) || (target + '단계');
          setStatus(label + '로 이동하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            state.stageChangePending = false;
            if (res && typeof res.stage !== 'undefined') {
              syncSessionState(res);
              setStatus(formatStageName(res.stage) + '로 이동했습니다.', 'success');
            } else {
              syncSessionState(res || {});
              setStatus('단계를 변경했습니다.', 'success');
            }
          }).withFailureHandler(function(err){
            state.stageChangePending = false;
            updateStepIndicator();
            handleError(err);
          }).jumpToStage(state.sessionKey, target, { force: true });
        }

        function onStepIndicatorClick(event){
          const step = Number(event.currentTarget && event.currentTarget.dataset.step);
          if (!step) return;
          navigateToStage(step);
        }

        function renderPrewritingPanel(){
          const textarea = $('prewritingInput');
          const readonly = $('prewritingReadonly');
          const info = $('prewritingInfo');
          if (!textarea || !readonly || !info) return;
          const defaultInfoText = buildPrewritingGuideHtml();
          const storedText = state.writing.prewriting.text || '';
          const submittedAt = Number(state.writing.prewriting.submittedAt || 0);
          const isStageActive = Number(state.stage || 1) === 1;
          const completed = Boolean(storedText && submittedAt);
          if (!completed && !state.localPrewritingDraft) {
            state.localPrewritingDraft = storedText;
          }
          const workingText = completed ? storedText : (typeof state.localPrewritingDraft === 'string' ? state.localPrewritingDraft : storedText);
          textarea.value = workingText;
          if (!completed && isStageActive) {
            state.localPrewritingDraft = workingText;
          }
          textarea.disabled = completed || !isStageActive;
          readonly.style.display = completed ? 'block' : 'none';
          readonly.textContent = completed ? storedText : '';
          const submitBtn = $('btnPreSubmit');
          if (submitBtn) submitBtn.disabled = !isStageActive || completed || !textarea.value.trim();
          if (completed) {
            info.textContent = '제출 시간: ' + formatDate(submittedAt);
          } else {
            info.innerHTML = defaultInfoText;
          }
        }

        function renderDraftPanel(){
          const textarea = $('draftInput');
          const info = $('draftInfo');
          const titleEl = $('draftTitle');
          const previewEl = $('prewritingPreview');
          const buttonRow = document.querySelector('#panelDraft .button-row');
          if (!textarea || !info) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const draftCopy = getPanelCopyEntry('draft');
          const overrideTitle = (draftCopy.title || '').trim();
          const overrideSubtitle = (draftCopy.subtitle || '').trim();
          // 3-1차시에서는 메모 작성 비활성화
          const editable = false;
          const savedText = state.writing.draft.text || '';
          if (previewEl) {
            const prewritingText = (state.writing.prewriting && state.writing.prewriting.text) || '';
            previewEl.textContent = prewritingText ? prewritingText : '2차시 메모가 아직 저장되지 않았습니다.';
          }
          if (savedText) {
            state.localDraftBuffer = savedText;
          }
          const workingText = stage === 2 ? (state.localDraftBuffer || savedText || '') : savedText;
          if (textarea.value !== workingText) textarea.value = workingText;
          textarea.style.display = 'none';
          textarea.disabled = true;
          if (buttonRow) buttonRow.style.display = 'none';
          if (titleEl && overrideTitle) {
            titleEl.textContent = overrideTitle;
          }
          const savedAt = Number(state.writing.draft.savedAt || 0);
          if (savedAt) {
            info.textContent = '마지막 메모 저장: ' + formatDate(savedAt);
          } else {
            const baseHtml =
              (info.dataset && info.dataset.baseHtml) ||
              overrideSubtitle ||
              'ChatGPT에게 받은 피드백을 참고하여, 글을 어떻게 수정할지에 대한 아이디어를 메모 형태로 자유롭게 정리하세요.';
            info.innerHTML = baseHtml;
          }
          const backBtn = $('btnDraftBack');
          if (backBtn) {
            const prevStage = getPreviousStageNumber();
            const currentStage = Number(state.stage || 1);
            if (prevStage < currentStage) {
              backBtn.disabled = false;
              backBtn.textContent = '← ' + (formatStageName(prevStage) || (prevStage + '단계')) + '로 이동';
            } else {
              backBtn.disabled = true;
              backBtn.textContent = '이전 단계로 이동';
            }
          }
        }

        function renderStage4DraftPanel(){
          const textarea = $('stage4DraftInput');
          const info = $('stage4DraftInfo');
          const titleEl = $('stage4DraftTitle');
          const promptEl = $('stage4DraftPromptContent');
          const prevMemoEl = $('stage4PrevMemoPreview');
          const stage3MemoEl = $('stage4Stage3MemoPreview');
          if (!textarea || !info || !titleEl || !promptEl || !prevMemoEl) return;
          const stage = Number(state.stage || 1);
          const show = stage === 4;
          if (!show) {
            textarea.value = '';
            return;
          }
          const stage4Label = getStageLabel(4) || {};
          const draftCopy = getPanelCopyEntry('draft');
          const overrideTitle = (draftCopy.title || '').trim();
          const overrideSubtitle = (draftCopy.subtitle || '').trim();
          const combinedTitle = stage4Label.headline
            ? `${stage4Label.name || '4차시-1'} · ${stage4Label.headline}`
            : (stage4Label.name || '4차시-1 · 토론 메모');
          if (titleEl) titleEl.textContent = overrideTitle || combinedTitle;

          const stage4Prompt = getStagePromptData(4);
          setRichText(
            'stage4DraftPromptContent',
            stage4Prompt.reference || stage4Label.description || '관리자가 등록한 발문이 여기에 표시됩니다.',
            '관리자가 등록한 발문이 여기에 표시됩니다.'
          );

          const prevMemo = (state.writing.prewriting && state.writing.prewriting.text) || '';
          prevMemoEl.textContent = prevMemo ? prevMemo : '2차시 메모가 아직 저장되지 않았습니다.';
          if (stage3MemoEl) {
            const memo = (state.writing.notes && state.writing.notes.text) || '';
            stage3MemoEl.textContent = memo ? memo : '3차시-2 성찰 메모가 아직 없습니다.';
          }

          // 3-1과 동일하게 입력은 비활성화 (구조 동일성 유지)
          const savedText = state.writing.draft.text || '';
          if (savedText) {
            state.localDraftBuffer = savedText;
          }
          const workingText = savedText;
          if (textarea.value !== workingText) textarea.value = workingText;
          textarea.style.display = 'none';
          textarea.disabled = true;
          const saveBtn = $('btnStage4DraftSave');
          if (saveBtn) saveBtn.disabled = true;

          const savedAt = Number(state.writing.draft.savedAt || 0);
          if (savedAt) {
            info.textContent = '마지막 메모 저장: ' + formatDate(savedAt);
          } else {
            info.textContent =
              overrideSubtitle ||
              stage4Label.description ||
              '입장을 바꿔 진행하는 4차시-1 토론에서 떠오른 주장·근거·반론을 점검하세요.';
          }
        }

        function renderPeerPanel(){
          const stage = Number(state.stage || 1);
          const isMemoStage = stage === 3;
          const currentLabel = getStageLabel(stage) || {};
          const titleEl = $('memoStage3Title');
          const infoEl = $('memoStage3Info');
          const notesInput = $('notesInput');
          const saveBtn = $('btnNotesSave');
          const nextBtn = $('btnPeerNext');
          // 새 DOM 구조가 없을 때 안전 종료
          if (!titleEl || !infoEl || !notesInput || !saveBtn) return;
          const memoCopy = getPanelCopyEntry('memo');
          const overrideTitle = (memoCopy.title || '').trim();
          const overrideSubtitle = (memoCopy.subtitle || '').trim();

          if (titleEl) {
            const combined = currentLabel.headline
              ? `${currentLabel.name || ''} · ${currentLabel.headline}`
              : currentLabel.name || '동료 메모';
            titleEl.textContent = overrideTitle || combined;
          }

          if (infoEl) {
            const baseHtml =
              overrideSubtitle ||
              infoEl.dataset.baseText ||
              currentLabel.description ||
              infoEl.innerHTML ||
              '';
            infoEl.dataset.baseText = baseHtml;
            let displayHtml = baseHtml;
            const memoSavedAt = Number(state.writing.notes.updatedAt || 0);
            if (memoSavedAt) {
              displayHtml += `<div class="muted" style="margin-top:4px;">마지막 저장: ${formatDate(memoSavedAt)}</div>`;
            }
            infoEl.innerHTML = displayHtml;
          }

          const transcriptBlock = document.querySelector('.stage3-transcript-block');
          if (transcriptBlock) transcriptBlock.style.display = stage === 3 ? 'block' : 'none';

          if (state.writing.notes && state.writing.notes.text) {
            if (!isMemoStage || !state.localStage3Memo || state.localStage3Memo === state.writing.notes.text) {
              state.localStage3Memo = state.writing.notes.text;
            }
          } else if (stage !== 3) {
            state.localStage3Memo = '';
          }

          const workingText = isMemoStage ? (state.localStage3Memo || state.writing.notes.text || '') : (state.writing.notes.text || '');
          if (notesInput.value !== workingText) notesInput.value = workingText;

          const memoEnabled = isMemoStage && !state.writing.final.submittedAt;
          notesInput.disabled = !memoEnabled;
          if (memoEnabled) state.localStage3Memo = notesInput.value;
          saveBtn.disabled = !memoEnabled || !notesInput.value.trim();

          if (nextBtn) {
            nextBtn.textContent = '최종 단계로 이동';
            const hasSaved = !!(state.writing.notes.text && state.writing.notes.updatedAt);
            nextBtn.disabled = !isMemoStage || !hasSaved;
          }

          renderStage3Transcript();

          // 이전/다음 단계 이동 버튼은 제거됨
        }

        function renderFinalPanel(){
          // 4차시는 발문/챗봇 중심 UI로 전환되어 최종 글쓰기 패널 사용 안 함
        }

        function renderStagePrompts(){
          const ui = publicConfig.uiText || DEFAULT_UI_TEXT;
          const stage1Prompt = getStagePromptData(1);
          setRichText(
            'promptContent',
            stage1Prompt.reference || publicConfig.promptContent,
            ui.promptEmptyText || '토론 발문이 아직 등록되지 않았습니다.'
          );
          const stage2Prompt = getStagePromptData(2);
          setRichText(
            'draftPromptContent',
            stage2Prompt.reference || stage1Prompt.reference || publicConfig.promptContent,
            ui.draftPromptEmptyText || '관리자가 등록한 발문이 여기에 표시됩니다.'
          );
          const stage3Prompt = getStagePromptData(3);
          setRichText(
            'stage3MemoHelper',
            '', // 3차시-2 하단 안내 문구 제거 (관리자 설정 무시)
            ''
          );
          const stage4Prompt = getStagePromptData(4);
          setRichText(
            'stage4PromptContent',
            stage4Prompt.reference || publicConfig.promptContent,
            ui.stage4PromptEmptyText || '관리자가 등록한 발문이 여기에 표시됩니다.'
          );
          setRichText(
            'stage4DraftPromptContent',
            stage4Prompt.reference || publicConfig.promptContent,
            ui.stage4PromptEmptyText || '관리자가 등록한 발문이 여기에 표시됩니다.'
          );
          const stage5Prompt = getStagePromptData(5);
          setRichText(
            'stage5TranscriptSummary',
            stage5Prompt.reference || '4-1 토론 기록을 불러오는 중입니다. (추후 연동)',
            '4-1 토론 기록을 불러오는 중입니다. (추후 연동)'
          );
          setRichText(
            'stage5MemoHelper',
            stage5Prompt.reference || '4-1차시 대화를 평가하고 피드백을 정리하세요.',
            '4-1차시 대화를 평가하고 피드백을 정리하세요.'
          );
        }

        function recordAiTranscript(message, ts){
          if (!message) return;
          const stage =
            Number(message?.ext?.stage) ||
            Number(message?.stage) ||
            Number(message?.metadata?.stage) ||
            inferMissingAiStage() ||
            0;
          if (!stage) return;
          const text = (message.text || '').trim();
          if (!text) return;
          const numericTs = Number(ts || message.ts || 0);
          // 시스템/웰컴/가이드 메시지는 기록에서 제외
          const defaultGuideMessages = [
            '동료와 상호 피드백을 주고받으며 논거를 점검하세요.',
            '토론 관련 발문을 바탕으로 쟁점과 논거를 정리하세요.'
          ];
          if (message.role === 'system' || numericTs <= 0 || defaultGuideMessages.includes(text)) return;
          const key =
            stage +
            ':' +
            (message.role || 'user') +
            ':' +
            (message.senderId || '') +
            ':' +
            (ts || message.ts || 0) +
            ':' +
            (message.text || '').slice(0, 120);
          if (state.aiTranscriptKeys[key]) return;
          state.aiTranscriptKeys[key] = true;
          if (!state.aiStageLogs[stage]) state.aiStageLogs[stage] = [];
          state.aiStageLogs[stage].push({
            stage,
            ts: ts || message.ts || Date.now(),
            role: message.role || 'user',
            sender: message.senderName || (message.role === 'ai' ? 'AI' : state.user.name || '학생'),
            text: message.text || '',
          });
          if (state.aiStageLogs[stage].length > 150) {
            state.aiStageLogs[stage] = state.aiStageLogs[stage].slice(-150);
          }
          if (stage === 2 && Number(state.stage || 1) >= 3) {
            renderStage3Transcript();
          }
          if (stage === 4 && Number(state.stage || 1) >= 5) {
            renderStage5Transcript();
          }
        }

        function inferMissingAiStage(){
          const current = Number(state.stage || 0);
          if (!current) return 0;
          if (state.typeMode === TYPE_KEYS.TYPE_A) {
            if (current >= 5) return 4; // 회고 단계에서는 직전 4-1 기록을 보여줘야 함
            if (current >= 3) return 2; // 성찰 단계에서는 3-1 기록을 기본으로 사용
          }
          return current;
        }

        function getAiTranscriptEntries(stage){
          return (state.aiStageLogs[stage] || []).slice();
        }

        function formatTranscriptEntries(entries){
          if (!entries.length) return '';
          return entries
            .map((entry) => {
              const speaker = entry.role === 'ai' ? 'AI' : '학생';
              return `${speaker}: ${entry.text || ''}`;
            })
            .join('\n');
        }

        function buildAiFeedbackContext(stage){
          if (state.typeMode === TYPE_KEYS.TYPE_A && stage === 3) {
            const entries = getAiTranscriptEntries(2);
            if (!entries.length) return '';
            return `이전 3-1차시 토론 기록:\n${formatTranscriptEntries(entries)}`;
          }
          if (state.typeMode === TYPE_KEYS.TYPE_A && stage === 5) {
            const entries = getAiTranscriptEntries(4);
            if (!entries.length) return '';
            return `이전 4-1차시 토론 기록:\n${formatTranscriptEntries(entries)}`;
          }
          return '';
        }

        function renderStage3Transcript(){
          const container = $('stage3Transcript');
          if (!container) return;
          const logs = (state.aiStageLogs[2] || []).slice(-12);
          if (!logs.length) {
            container.innerHTML =
              '<div class="stage3-transcript-line">3-1차시 토론 기록이 아직 없습니다.</div>';
            return;
          }
          const html = logs
            .map(function(entry){
              const label = entry.role === 'ai' ? 'AI 응답' : '나의 질문';
              const text = escapeHtml(entry.text || '').replace(/\n/g, '<br/>');
              return `<div class="stage3-transcript-line ${entry.role === 'ai' ? 'ai' : 'me'}"><span class="label">${label}</span>${text}</div>`;
            })
            .join('');
          container.innerHTML = html;
        }

        function renderStage5Panel(){
          const memoInput = $('stage5MemoInput');
          const saveBtn = $('btnStage5MemoSave');
          const transcriptGrid = $('stage5ReviewGrid');
          const summaryBlock = $('stage5SummaryBlock');
          const isTypeA = state.typeMode === TYPE_KEYS.TYPE_A;
          const stage = Number(state.stage || 1);
          const enabled = stage >= 5;
          const memoText = state.localStage5Memo || '';
          const showTranscriptGrid = isTypeA && enabled;
          if (transcriptGrid) transcriptGrid.style.display = showTranscriptGrid ? 'flex' : 'none';
          if (summaryBlock) summaryBlock.style.display = showTranscriptGrid ? 'none' : 'block';
          if (showTranscriptGrid) {
            renderStage5Transcript();
            renderStage5PrevMemo();
          }
          if (memoInput) {
            memoInput.value = memoText;
            memoInput.disabled = !enabled;
          }
          if (saveBtn) {
            saveBtn.disabled = !enabled || !memoText.trim();
          }
        }

        function renderStage5Transcript(){
          const container = $('stage5Transcript');
          const heading = $('stage5TranscriptHeading');
          const block = $('stage5TranscriptBlock');
          if (!container || !heading || !block) return;
          const isTypeA = state.typeMode === TYPE_KEYS.TYPE_A;
          block.style.display = isTypeA ? 'block' : 'none';
          if (!isTypeA) return;
          heading.textContent = '4-1차시 토론 기록';
          const entries = getAiTranscriptEntries(4);
          if (!entries.length) {
            container.innerHTML = '<div class="stage3-transcript-line">4-1차시 토론 기록이 아직 없습니다.</div>';
            return;
          }
          container.innerHTML = entries
            .map(function(entry){
              const label = entry.role === 'ai' ? 'AI 응답' : '학생';
              const text = escapeHtml(entry.text || '').replace(/\n/g, '<br/>');
              return `<div class="stage3-transcript-line ${entry.role === 'ai' ? 'ai' : 'me'}"><span class="label">${label}</span>${text}</div>`;
            })
            .join('');
        }

        function renderStage5PrevMemo(){
          const container = $('stage5PrevMemo');
          const heading = $('stage5PrevMemoHeading');
          if (!container || !heading) return;
          heading.textContent = '3-2차시 성찰 메모';
          const memo = (state.writing.notes && state.writing.notes.text) || '';
          if (!memo.trim()) {
            container.innerHTML = '<div class="stage3-transcript-line">3-2차시 메모가 아직 없습니다.</div>';
            return;
          }
          container.innerHTML = `<div class="stage3-transcript-line">${escapeHtml(memo).replace(/\n/g, '<br/>')}</div>`;
        }

        function renderFinalChatPanel(){
          const logEl = $('finalChatLog');
          const inputEl = $('finalChatInput');
          const sendBtn = $('btnFinalChatSend');
          const stage = Number(state.stage || 1);
          const aiEnabled = !!state.aiChat.sessionId && stage >= 4;
          // 로그는 초기화하지 않고 유지해, 자동 새로고침 시 대화가 사라지지 않도록 함
          if (inputEl) inputEl.disabled = !aiEnabled || (state.aiChat && state.aiChat.awaitingResponse);
          if (sendBtn) sendBtn.disabled = !aiEnabled || (state.aiChat && state.aiChat.awaitingResponse);
        }

        function onSaveStage5Memo(){
          const memoInput = $('stage5MemoInput');
          if (!memoInput) return;
          const text = memoInput.value.trim();
          const stage5Name = getStageDisplayName(5);
          if (!text) { setStatus(`${stage5Name} 메모를 입력하세요.`, 'warn'); return; }
          state.localStage5Memo = text;
          const btn = $('btnStage5MemoSave');
          if (btn) btn.disabled = true;
          setStatus(`${stage5Name} 메모가 로컬에 저장되었습니다. (서버 연동 필요)`, 'success');
        }

        function isAiChatStage(stage){
          const config = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const list = Array.isArray(config.aiStages) ? config.aiStages : [];
          return list.includes(Number(stage || 0));
        }

        function isPeerChatStage(stage){
          const config = getTypeConfig(state.typeMode || TYPE_KEYS.TYPE_A);
          const list = Array.isArray(config.peerStages) ? config.peerStages : [];
          return list.includes(Number(stage || 0));
        }

        function renderRightPanels(){
          const stage = Number(state.stage || 1);
          // 4-1차시(스테이지 4)에서는 단일 챗봇(rightStage4)만 사용
          const showAiChat = isAiChatStage(stage) && stage < 4;
          const showPeerChat = isPeerChatStage(stage);
          const showFinalChat = stage >= 4;
          if (showAiChat) updateAiPanelHeader(stage);
          if (showPeerChat) updatePeerPanelHeader(stage);
          if (showFinalChat) updateFinalChatHeader(stage);
          togglePanel('rightStage2', showAiChat);
          togglePanel('rightStage3', showPeerChat);
          togglePanel('rightStage4', showFinalChat);
        }

        function updateFinalChatHeader(stage){
          if (stage >= 5) {
            setText('finalStageTitle', '4차시-2 ChatGPT와 토론 성찰');
            setText(
              'finalStageSubtitle',
              '이제 ChatGPT는 토론 상대자가 아닌 토론 성찰을 지원하는 AI입니다.\n\n현재 창에는 ChatGPT와 진행한 토론 기록이 있으며, 성찰 지원 ChatGPT에는 토론 평가 기준이 트레이닝 되어 있습니다.\n\n토론 기록과, 1차 토론 성찰 메모, 토론 성찰 지원 AI와의 대화를 통해 토론에서 드러난 자신의 강점과 보완점을 함께 점검해 보세요.\n\n이 활동의 목적은 점수 평가가 아니라 다음 토론을 더 잘하기 위한 성찰과 개선 방향 탐색입니다.\n\n예를 들어 다음과 같은 질문을 할 수 있습니다.\n- 나의 토론을 평가해주고, 점수를 매겨줄 수 있나요?\n- 어떤 기준으로 토론을 평가하는 건가요?\n- 내 주장은 토론 전반에서 일관되게 유지되었나요?\n- 내가 사용한 근거 중 가장 설득력이 있었던 / 있지 않았던 근거는 무엇인가요?\n- 내가 대응한 반박 중에 논리력이 있었던 / 있지 않았던 것은 무엇인가요?\n- 동일한 반박이 다시 나온다면, 더 나은 재반박 예시를 제안해 줄 수 있나요?\n- 나의 토론을 보완한다면 어떤 것을 보완해야 하나요?'
            );
            return;
          }
          const stageNumber = Number(stage || 1);
          if (stageNumber === 4) {
            setText('finalStageTitle', '4차시-1 ChatGPT와 토론');
            const finalSub = $('finalStageSubtitle');
            if (finalSub) {
              const line1 = '<strong><u>이번 차시에서는 이전 차시와 \'반대입장\'에서 토론을 진행합니다.</u></strong>';
              const line2 =
                '당신이 반대입장이므로, ChatGPT는 찬성입장에서 토론합니다. 즉, 이번 차시는 기존에 주장했던 입장을 그대로 반복하는 것이 아니라, 반대 관점을 이해하고, 그 입장에서 논증하는 활동입니다.';
              finalSub.innerHTML = [line1, line2].join('<br/>');
            }
            return;
          }
          const label = getStageLabel(stageNumber);
          const finalCopy = getPanelCopyEntry('final');
          const combined = label?.headline ? `${label.name || ''} · ${label.headline}` : label?.name;
          setText('finalStageTitle', finalCopy.title || combined || 'ChatGPT와 토론');
          setText('finalStageSubtitle', finalCopy.subtitle || label?.description || '관리자 시스템 프롬프트를 기반으로 토론을 진행합니다.');
        }

        function updateAiPanelHeader(stage){
          const stageNumber = Number(stage || 1);
          const label = getStageLabel(stageNumber);
          const aiCopy = getPanelCopyEntry('ai');
          // 2차시(내부 스테이지 번호 1)에서는 고정된 가이드 HTML을 사용해 관리자 설정과 무관하게 서식을 유지
          if (stageNumber === 1) {
            setText('aiStageTitle', '2차시 토론 논제 관련 ChatGPT 활용');
            const aiSubtitle = $('aiStageSubtitle');
            if (aiSubtitle) aiSubtitle.innerHTML = buildAiGuideHtml();
            const aiInput = $('aiInput');
            if (aiInput) {
              aiInput.setAttribute('placeholder', 'AI에게 토론 준비와 관련된 질문을 하세요.');
            }
            return;
          }
          // 3차시-1(내부 스테이지 번호 2)도 관리자 설정을 무시하고 고정 문구 적용
          if (stageNumber === 2) {
            setText('aiStageTitle', '3차시-1 ChatGPT와의 토론');
            const aiSubtitle = $('aiStageSubtitle');
            if (aiSubtitle) {
              const line1 = '이제 ChatGPT는 당신의 입장과 반대되는 관점을 가진 토론 상대로 설정됩니다.';
              const line2 = '<strong><u>당신이 찬성 입장이므로, ChatGPT는 반대 입장에서 토론합니다.</u></strong>';
              const line3 = 'ChatGPT의 질문과 반박에 대해 주장-근거-재반박의 구조를 의식하며 충분히 토론을 진행해 보세요.';
              aiSubtitle.innerHTML = [line1, line2, line3].join('<br/>');
            }
            return;
          }
          // 3차시-2(내부 스테이지 번호 3) 안내
          if (stageNumber === 3) {
            setText('aiStageTitle', '3차시-2 ChatGPT와 토론 성찰');
            const aiSubtitle = $('aiStageSubtitle');
            if (aiSubtitle) {
              const lead = '<strong><u>이제 ChatGPT는 토론 상대자가 아닌 토론 성찰을 지원하는 AI입니다.</u></strong>';
              const line2 =
                '<strong><u>토론 기록과, 토론 성찰 지원 AI와의 대화를 통해 토론에서 드러난 자신의 강점과 보완점을 함께 점검해 보세요.</u></strong> 예를 들어 다음과 같은 질문을 할 수 있습니다.';
              const bullets = [
                '나의 토론을 평가해주고, 점수를 매겨줄 수 있나요?',
                '내가 사용한 근거 중 가장 설득력이 있었던 / 있지 않았던 근거는 무엇인가요?',
                '내가 대응한 반박 중에 논리력이 있었던 / 있지 않았던 것은 무엇인가요?',
                '나의 토론을 보완한다면 어떤 것을 보완해야 하나요?'
              ];
              const list = `<ul style="margin:8px 0 0 18px; padding-left:0; line-height:1.55;">${bullets
                .map((item) => `<li style="list-style: disc; margin-left:0;">${item}</li>`)
                .join('')}</ul>`;
              aiSubtitle.innerHTML = [lead, line2, list].join('<br/>');
            }
            return;
          }
          if (!label && !aiCopy) return;
          const combined = label?.headline ? `${label.name} · ${label.headline}` : label?.name;
          const title = stageNumber === 1 ? (aiCopy.title || combined) : (combined || aiCopy.title);
          const subtitle = stageNumber === 1 ? (aiCopy.subtitle || label?.description) : (label?.description || aiCopy.subtitle);
          setText('aiStageTitle', title || 'AI 토론');
          setText('aiStageSubtitle', subtitle || 'AI와 토론을 이어가며 논거를 점검하세요.');
        }

        function updatePeerPanelHeader(stage){
          const label = getStageLabel(stage);
          const peerCopy = getPanelCopyEntry('peer');
          const titleEl = $('peerStageTitle');
          const subtitleEl = $('peerStageSubtitle');
          if (!titleEl || !subtitleEl) return;
          if (!label && !peerCopy) return;
          const combined = label?.headline ? `${label.name} · ${label.headline}` : label?.name;
          setText('peerStageTitle', (peerCopy.title || combined || '동료 토론'));
          setText('peerStageSubtitle', (peerCopy.subtitle || label?.description || '동료와 상호작용하며 피드백을 주고받으세요.'));
        }

        function togglePanel(id, visible){
          const el = $(id);
          if (!el) return;
          el.style.display = visible ? 'flex' : 'none';
        }

        function renderPartnerPanel(){
          const partner = state.partner;
          const stage = Number(state.stage || 1);
          const nameEl = $('partnerName');
          const infoEl = $('partnerInfoBox');
          if (!nameEl || !infoEl) return;
          const isPeerStage = isPeerChatStage(stage);
          if (partner) {
            nameEl.textContent = (partner.name || '동료') + ' 학생';
            const peerStageName = formatStageName(partner.stage || 1);
            infoEl.textContent = (isPeerStage ? '동료와 실시간 피드백 단계입니다. 동료 단계: ' : '현재 단계: ') + peerStageName;
          } else {
            nameEl.textContent = '동료 정보를 불러오는 중...';
            if (isPeerStage) {
              infoEl.textContent = '동료 매칭 정보를 기다리고 있습니다.';
            } else {
              infoEl.textContent = '이 단계에서는 동료 정보가 필요하지 않습니다.';
            }
          }
        }

        function renderPresence(){
          const selfEl = $('peerPresenceSelf');
          const partnerEl = $('peerPresencePartner');
          const selfDot = $('selfPresenceDot');
          const partnerDot = $('partnerPresenceDot');
          // 우측 동료 패널이 없는 상태라면 스킵
          if (!selfEl || !partnerEl || !selfDot || !partnerDot) return;
          const selfInfo = state.presence && state.presence.self;
          const partnerInfo = state.presence && state.presence.partner;
          const selfText = describePresence(selfInfo);
          const partnerText = describePresence(partnerInfo);
          selfEl.textContent = selfText;
          partnerEl.textContent = partnerText;
          updatePresenceDot('selfPresenceDot', selfInfo && selfInfo.online);
          updatePresenceDot('partnerPresenceDot', partnerInfo && partnerInfo.online);
        }

        // AI 웰컴 메시지는 사용하지 않습니다.

        function setAiPending(waiting){
          if (!state.aiChat) return;
          state.aiChat.awaitingResponse = !!waiting;
          refreshChatControls();
        }

        function updatePresenceDot(id, online){
          const dot = $(id);
          if (!dot) return;
          dot.classList.toggle('presence-online', !!online);
          dot.classList.toggle('presence-offline', !online);
        }

        function renderDictionaryHistory(){
          const historyEl = $('dictHistory');
          const emptyEl = $('dictEmpty');
          if (!historyEl || !emptyEl) return;
          historyEl.innerHTML = '';
          if (!state.dictionaryHistory.length) {
            emptyEl.style.display = 'block';
            return;
          }
          emptyEl.style.display = 'none';
          state.dictionaryHistory.slice(-5).reverse().forEach(function(entry){
            const row = document.createElement('div');
            row.className = 'history-item';
            const term = document.createElement('span');
            term.className = 'term';
            term.textContent = entry.word || '';
            const arrow = document.createElement('span');
            arrow.className = 'direction';
            arrow.textContent = formatDictionaryDirection(entry.direction) || '→';
            const summary = document.createElement('span');
            summary.className = 'translation';
            summary.textContent = entry.summary || '';
            const time = document.createElement('span');
            time.className = 'time';
            time.textContent = formatTime(entry.timestamp);
            row.appendChild(term);
            row.appendChild(arrow);
            row.appendChild(summary);
            row.appendChild(time);
            row.addEventListener('click', function(){
              if (entry.data) renderDictionaryResult(entry.data);
            });
            historyEl.appendChild(row);
          });
        }

        function refreshChatControls(){
          const stage = Number(state.stage || 1);
          const aiEnabled = !!state.aiChat.sessionId && isAiChatStage(stage);
          const aiPending = state.aiChat && state.aiChat.awaitingResponse;
          const aiInput = $('aiInput');
          const aiBtn = $('btnAiSend');
          const finalInput = $('finalChatInput');
          const finalBtn = $('btnFinalChatSend');
          if (aiInput) aiInput.disabled = !aiEnabled || aiPending || stage >= 4;
          if (aiBtn) aiBtn.disabled = !aiEnabled || aiPending || stage >= 4;
          if (finalInput) finalInput.disabled = !aiEnabled || aiPending || stage < 4;
          if (finalBtn) finalBtn.disabled = !aiEnabled || aiPending || stage < 4;
          const peerEnabled = !!state.peerChat.sessionId && isPeerChatStage(stage);
          const peerInput = $('peerInput');
          const peerBtn = $('btnPeerSend');
          if (peerInput) peerInput.disabled = !peerEnabled;
          if (peerBtn) peerBtn.disabled = !peerEnabled;
        }

        function onSubmitPrewriting(){
          if (!hasGas) return;
          if (!state.sessionKey) { setStatus('세션이 활성화되지 않았습니다.', 'error'); return; }
          const text = $('prewritingInput').value.trim();
          if (!text) { setStatus('사전 글쓰기 내용을 입력하세요.', 'warn'); return; }
          $('btnPreSubmit').disabled = true;
          setStatus('사전 글쓰기를 제출하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            state.stage = Math.max(2, Number(state.stage || 1));
            setStatus('사전 글쓰기를 제출했습니다.', 'success');
            syncSessionState(res);
            if (state.stage < 2) {
              state.stage = 2;
              renderWorkspace();
            }
          }).withFailureHandler(function(err){
            $('btnPreSubmit').disabled = false;
            handleError(err);
          }).submitPrewriting(state.sessionKey, text);
        }

        function onSaveDraft(){
          if (!hasGas) return;
          if (state.lastDraftSaveTime && Date.now() - state.lastDraftSaveTime < 2000) {
             setStatus('잠시 후 다시 저장해주세요.', 'warn');
             return;
          }
          state.lastDraftSaveTime = Date.now();
          const text = $('draftInput').value.trim();
          const stage2Name = getStageDisplayName(2);
          if (!text) { setStatus(`${stage2Name} 메모를 입력하세요.`, 'warn'); return; }
          $('btnSaveDraft').disabled = true;
          setStatus(`${stage2Name} 메모를 저장하는 중입니다...`, 'info');
          google.script.run.withSuccessHandler(function(res){
            state.localDraftBuffer = text;
            setStatus(`${stage2Name} 메모가 저장되었습니다.`, 'success');
            syncSessionState(res);
          }).withFailureHandler(function(err){
            $('btnSaveDraft').disabled = false;
            handleError(err);
          }).savePostDraft(state.sessionKey, text);
        }

        function onAdvanceToPeerStage(){
          if (!hasGas) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          if (stage === 2 && group === 'A') {
            if (!confirm('다음 단계로 이동하시겠습니까?')) return;
            $('btnToPeer').disabled = true;
            setStatus('다음 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('다음 단계로 이동했습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              $('btnToPeer').disabled = false;
              handleError(err);
            }).advanceToPeerStage(state.sessionKey);
          } else if (stage === 2 && group === 'C') {
            if (!confirm('최종 단계로 이동하시겠습니까?')) return;
            $('btnToPeer').disabled = true;
            setStatus('최종 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('최종 단계로 이동했습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              $('btnToPeer').disabled = false;
              handleError(err);
            }).advanceToPeerStage(state.sessionKey);
        } else {
            setStatus('현재 단계에서는 이동할 수 없습니다.', 'warn');
          }
        }

        function onPeerNextStage(){
          if (!hasGas) return;
          const stage = Number(state.stage || 1);
          const group = (state.group || '').toUpperCase();
          const btn = $('btnPeerNext');
          if (stage === 3 && group === 'A') {
            if (!confirm('최종 단계로 이동하시겠습니까?')) return;
            if (btn) btn.disabled = true;
            setStatus('최종 단계를 여는 중입니다...', 'info');
            google.script.run.withSuccessHandler(function(res){
              setStatus('최종 단계로 이동했습니다.', 'success');
              syncSessionState(res);
            }).withFailureHandler(function(err){
              if (btn) btn.disabled = false;
              handleError(err);
            }).advanceToFinalStage(state.sessionKey);
        } else {
            setStatus('현재 단계에서는 이동할 수 없습니다.', 'warn');
          }
        }

        function onGoToPreviousStage(event){
          if (!hasGas) return;
          if (!state.sessionKey) { setStatus('세션이 활성화되지 않았습니다.', 'error'); return; }
          const currentStage = Number(state.stage || 1);
          const prevStage = getPreviousStageNumber();
          if (prevStage >= currentStage) {
            setStatus('이전 단계가 없습니다.', 'warn');
            return;
          }
          const prevLabel = formatStageName(prevStage) || (prevStage + '단계');
          if (!confirm(prevLabel + '로 이동하시겠습니까?')) return;
          const trigger = event && event.currentTarget;
          if (trigger) trigger.disabled = true;
          state.stageChangePending = true;
          updateStepIndicator();
          setStatus(prevLabel + '로 이동하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            if (trigger) trigger.disabled = false;
            state.stageChangePending = false;
            if (res && res.stage) {
              if (Number(res.stage) < Number(state.stage || 1)) {
                state.stage = Number(res.stage);
              }
              syncSessionState(res);
              setStatus(formatStageName(res.stage) + '로 이동했습니다.', 'success');
            } else {
              setStatus('이전 단계로 이동했습니다.', 'success');
              syncSessionState(res || {});
            }
          }).withFailureHandler(function(err){
            if (trigger) trigger.disabled = false;
            state.stageChangePending = false;
            updateStepIndicator();
            handleError(err);
          }).regressStage(state.sessionKey);
        }

        function onSavePeerNotes(){
          if (!hasGas) return;
          if (state.lastPeerNotesSaveTime && Date.now() - state.lastPeerNotesSaveTime < 2000) {
             setStatus('잠시 후 다시 저장해주세요.', 'warn');
             return;
          }
          state.lastPeerNotesSaveTime = Date.now();
          const stage = Number(state.stage || 1);
          const stageDisplayName = getStageDisplayName(stage);
          const isMemoStage = stage === 3;
          if (!isMemoStage) { setStatus(`${stageDisplayName} 단계에서만 저장할 수 있습니다.`, 'warn'); return; }
          const text = $('notesInput').value || '';
          if (!text.trim()) {
            $('btnNotesSave').disabled = false;
            setStatus(`${stageDisplayName} 메모를 입력하세요.`, 'warn');
            return;
          }
          $('btnNotesSave').disabled = true;
          setStatus(`${stageDisplayName} 메모를 저장하는 중입니다...`, 'info');
          const cleanedText = text.trim();
          google.script.run.withSuccessHandler(function(res){
            state.localStage3Memo = cleanedText;
            setStatus(`${stageDisplayName} 메모가 저장되었습니다.`, 'success');
            syncSessionState(res);
          }).withFailureHandler(function(err){
            $('btnNotesSave').disabled = false;
            handleError(err);
          }).savePeerNotes(state.sessionKey, cleanedText);
        }
        function onSubmitFinalWriting(){
          if (!hasGas) return;
          const stage = Number(state.stage || 1);
          if (stage !== 4) { setStatus('최종 단계에서만 제출할 수 있습니다.', 'warn'); return; }
          const textArea = $('finalInput');
          const content = (state.localFinalDraft || (textArea ? textArea.value : '') || '').trim();
          if (!content) { setStatus('최종 글을 작성하세요.', 'warn'); return; }
          if (!confirm('현재 작성한 최종 글을 제출하시겠습니까? 제출 후에는 수정할 수 없습니다.')) return;
          const btn = $('btnFinalSubmit');
          if (btn) btn.disabled = true;
          setStatus('최종 결과를 제출하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            setStatus('최종 제출이 완료되었습니다.', 'success');
            syncSessionState(res);
          }).withFailureHandler(function(err){
            if (btn) btn.disabled = false;
            handleError(err);
          }).submitFinalWriting(state.sessionKey, content);
        }

        function extractPrimaryMeaning(data){
          if (!data || !Array.isArray(data.entries)) return '';
          for (var i = 0; i < data.entries.length; i++) {
            var entry = data.entries[i];
            if (!entry || !Array.isArray(entry.meanings)) continue;
            for (var j = 0; j < entry.meanings.length; j++) {
              var meaning = entry.meanings[j];
              if (meaning && String(meaning).trim()) {
                return String(meaning).trim();
              }
            }
          }
          return '';
        }

        function resolveDictionaryDirection(data, fallbackQuery){
          if (data && data.direction) return data.direction;
          var source = '';
          if (data && data.word) source = String(data.word);
          if (!source && fallbackQuery) source = String(fallbackQuery);
          if (!source) return 'en-ko';
          var hasHangul = /[\u3131-\u318E\uAC00-\uD7A3]/.test(source);
          var hasLatin = /[A-Za-z]/.test(source);
          if (hasHangul && !hasLatin) return 'ko-en';
          if (hasLatin && !hasHangul) return 'en-ko';
          return hasHangul ? 'ko-en' : 'en-ko';
        }

        function formatDictionaryDirection(direction){
          if (direction === 'ko-en') return '한→영';
          if (direction === 'en-ko') return '영→한';
          return '';
        }

        function onDictionarySearch(){
          if (!hasGas) return;
          const query = $('dictQuery').value.trim();
          if (!query) { setStatus('검색어를 입력하세요.', 'warn'); return; }
          $('btnDictSearch').disabled = true;
          setStatus('사전을 조회하는 중입니다...', 'info');
          google.script.run.withSuccessHandler(function(res){
            $('btnDictSearch').disabled = false;
            if (res && res.ok && res.data) {
              const direction = resolveDictionaryDirection(res.data, query);
              const normalizedData = Object.assign({}, res.data, { direction: direction });
              renderDictionaryResult(normalizedData);
              const primaryMeaning = extractPrimaryMeaning(normalizedData);
              const historyEntry = {
                word: normalizedData.word || query,
                pronunciation: normalizedData.pronunciation || '',
                summary: primaryMeaning,
                direction: normalizedData.direction,
                timestamp: Date.now(),
                data: normalizedData
              };
              state.dictionaryHistory.push(historyEntry);
              if (state.dictionaryHistory.length > 10) state.dictionaryHistory = state.dictionaryHistory.slice(-10);
              renderDictionaryHistory();
              setStatus('사전 검색 결과가 업데이트되었습니다.', 'success');
        } else {
              renderDictionaryResult(null, res && res.message ? res.message : '사전 결과가 없습니다.');
              setStatus(res && res.message ? res.message : '사전 검색에 실패했습니다.', 'warn');
            }
          }).withFailureHandler(function(err){
            $('btnDictSearch').disabled = false;
            renderDictionaryResult(null, err && err.message ? err.message : '사전 검색 중 오류가 발생했습니다.');
            handleError(err);
          }).lookupDictionary(query);
        }

        function renderDictionaryResult(data, message){
          const result = $('dictResult');
          if (!result) return;
          result.innerHTML = '';
          if (!data) {
            const word = document.createElement('div');
            word.className = 'dict-word';
            word.textContent = message || '검색 결과가 없습니다.';
            result.appendChild(word);
          return;
        }
          const direction = resolveDictionaryDirection(data);
          const directionLabel = formatDictionaryDirection(direction);
          const primaryMeaning = extractPrimaryMeaning(data);
          const headingParts = [];
          if (directionLabel) headingParts.push(directionLabel);
          if (data.word) headingParts.push(data.word);
          if (primaryMeaning && primaryMeaning !== data.word) headingParts.push(primaryMeaning);
          const headingEl = document.createElement('div');
          headingEl.className = 'dict-word';
          headingEl.textContent = headingParts.length ? headingParts.join(' · ') : (data.word || '사전 검색 결과');
          result.appendChild(headingEl);
          if (data.pronunciation) {
            const pron = document.createElement('div');
            pron.className = 'dict-pron';
            pron.textContent = data.pronunciation;
            result.appendChild(pron);
          }
          if (Array.isArray(data.entries) && data.entries.length) {
            const entriesWrap = document.createElement('div');
            entriesWrap.className = 'dict-section';
            data.entries.forEach(function(entry){
              const item = document.createElement('div');
              item.className = 'dict-entry';
              const pos = document.createElement('strong');
              pos.textContent = entry.pos || '';
              item.appendChild(pos);
              if (Array.isArray(entry.meanings) && entry.meanings.length) {
                const list = document.createElement('ul');
                list.style.margin = '6px 0 0 12px';
                list.style.padding = '0';
                list.style.listStyle = 'disc';
                entry.meanings.forEach(function(m){
                  const li = document.createElement('li');
                  li.textContent = m;
                  list.appendChild(li);
                });
                item.appendChild(list);
              }
              entriesWrap.appendChild(item);
            });
            result.appendChild(entriesWrap);
          }
          if (Array.isArray(data.examples) && data.examples.length) {
            const examplesWrap = document.createElement('div');
            examplesWrap.className = 'dict-examples';
            data.examples.forEach(function(example){
              const row = document.createElement('div');
              row.className = 'dict-example';
              const primaryKey = direction === 'ko-en' ? 'ko' : 'en';
              const secondaryKey = direction === 'ko-en' ? 'en' : 'ko';
              const primaryDiv = document.createElement('div');
              primaryDiv.style.color = '#1f2937';
              primaryDiv.style.fontWeight = '600';
              primaryDiv.textContent = example[primaryKey] || '';
              const secondaryDiv = document.createElement('div');
              secondaryDiv.style.color = '#2563eb';
              secondaryDiv.textContent = example[secondaryKey] || '';
              row.appendChild(primaryDiv);
              row.appendChild(secondaryDiv);
              examplesWrap.appendChild(row);
            });
            result.appendChild(examplesWrap);
          }
        }

        function sendAiMessage(){
          if (!hasGas) return;
          if (!state.aiChat.sessionId) { setStatus('AI 세션이 준비되지 않았습니다.', 'error'); return; }
          const stage = Number(state.stage || 1);
          if (!isAiChatStage(stage)) {
            setStatus('AI 피드백 단계에서만 사용할 수 있습니다.', 'warn');
            return;
          }
          const { input } = getAiUiRefs();
          if (!input || input.disabled) return;
          const text = input.value.trim();
          if (!text) return;
          const contextText = buildAiFeedbackContext(stage);
          input.value = '';
          const localMessage = {
            ts: Date.now(),
            role: 'user',
            senderId: state.user.id,
            senderName: state.user.name,
            text,
            stage,
            ext: { stage },
          };
          const appended = appendChatMessage('ai', localMessage, { pending: true });
          setAiPending(true);
          setAiLoading(true);
        google.script.run.withSuccessHandler(function(res){
            if (appended && appended.tempId && res && typeof res.ts === 'number') {
              confirmChatMessage('ai', appended.tempId, res.ts, localMessage);
            }
            pollAiMessages();
          google.script.run.withSuccessHandler(function(ai){
              if (ai && ai.text) pollAiMessages();
            }).withFailureHandler(function(err){
              setAiLoading(false);
              setAiPending(false);
              handleError(err);
            }).requestAiIfNeeded(state.aiChat.sessionId, state.group, text, contextText, { channel: 'ai-feedback', sessionKey: state.sessionKey, stage: state.stage });
          }).withFailureHandler(function(err){
            setAiLoading(false);
            setAiPending(false);
            if (appended && appended.element) appended.element.classList.add('error');
            handleError(err);
          }).postMessage(state.aiChat.sessionId, state.group, state.user.id, state.user.name, 'user', text, { channel: 'ai-feedback', sessionKey: state.sessionKey, stage: state.stage });
        }

        function setAiLoading(flag){
          const { loader } = getAiUiRefs();
          if (loader) loader.style.display = flag ? 'flex' : 'none';
          if (flag) {
            const { sendBtn } = getAiUiRefs();
            if (sendBtn) sendBtn.disabled = true;
          } else {
            refreshChatControls();
          }
        }

        function sendPeerMessage(){
          if (!hasGas || !state.peerChat.sessionId) return;
          const stage = Number(state.stage || 1);
          const isPeerStage = isPeerChatStage(stage);
          if (!isPeerStage) { setStatus('동료 협업 단계에서만 사용할 수 있습니다.', 'warn'); return; }
          const input = $('peerInput');
          if (!input || input.disabled) return;
          const text = input.value.trim();
          if (!text) return;
          input.value = '';
          const local = { ts: Date.now(), role: 'user', senderId: state.user.id, senderName: state.user.name, text: text };
          const appended = appendChatMessage('peer', local, { pending: true });
        google.script.run.withSuccessHandler(function(res){
            if (appended && appended.tempId && res && typeof res.ts === 'number') {
              confirmChatMessage('peer', appended.tempId, res.ts, local);
            }
            pollPeerMessages();
          }).withFailureHandler(function(err){
            if (appended && appended.element) appended.element.classList.add('error');
            handleError(err);
          }).postMessage(state.peerChat.sessionId, state.group, state.user.id, state.user.name, 'user', text, { channel: 'peer-chat', sessionKey: state.sessionKey, roomId: state.peerChat.sessionId });
        }

        function buildChatDedupeKey(message, ts){
          const time = Number(ts || message.ts || 0) || 0;
          const sender = String(message.senderId || message.role || '');
          const text = String(message.text || '');
          return time + '|' + sender + '|' + text;
        }

        function appendChatMessage(channel, message, options){
          const chatState = channel === 'ai' ? state.aiChat : state.peerChat;
          const messageStage =
            Number(message?.ext?.stage) ||
            Number(message?.stage) ||
            Number(message?.metadata?.stage) ||
            0;
          const logEl =
            channel === 'ai'
              ? getAiLogElementForStage(messageStage || state.stage)
              : $('peerChatLog');
          if (!chatState || !logEl) return null;
          const isPending = options && options.pending;
          const ts = Number(message.ts || Date.now());
          const dedupeKey = buildChatDedupeKey(message, ts);
          // AI 채팅에서 현재 단계가 아닌 메시지는 로그에 그리지 않고 기록만 남김
          if (channel === 'ai' && !isPending) {
            const currentStage = Number(state.stage || 1);
            const messageStage =
              Number(message?.ext?.stage) ||
              Number(message?.stage) ||
              Number(message?.metadata?.stage) ||
              0;
            if (messageStage && messageStage !== currentStage) {
              chatState.rendered[dedupeKey] = true;
              if (ts > chatState.lastTs) chatState.lastTs = ts;
              recordAiTranscript(message, ts);
              return null;
            }
          }
          if (!isPending) {
            if (chatState.pending && Object.keys(chatState.pending).length) {
              let matchedTempId = '';
              Object.keys(chatState.pending).forEach(function(tempId){
                if (matchedTempId) return;
                const pendingNode = chatState.pending[tempId];
                if (!pendingNode) return;
                const pendingSender = pendingNode.dataset.senderId || '';
                if (String(pendingSender) !== String(message.senderId || '')) return;
                const bubbleEl = pendingNode.querySelector('.chat-bubble');
                if (!bubbleEl) return;
                if (bubbleEl.textContent === (message.text || '')) {
                  matchedTempId = tempId;
                }
              });
              if (matchedTempId) {
                const pendingNode = chatState.pending[matchedTempId];
                delete chatState.pending[matchedTempId];
                pendingNode.classList.remove('pending');
                if (ts) pendingNode.dataset.ts = String(ts);
                const metaEl = pendingNode.querySelector('.chat-meta');
                if (metaEl) metaEl.textContent = buildChatMeta(channel, message, ts, false);
                chatState.rendered[dedupeKey] = true;
                if (ts > chatState.lastTs) chatState.lastTs = ts;
                if (channel === 'ai' && message.role === 'ai') {
                  setAiPending(false);
                  setAiLoading(false);
                }
                return { tempId: matchedTempId, element: pendingNode };
              }
            }
            if (chatState.rendered[dedupeKey]) return null;
            chatState.rendered[dedupeKey] = true;
            if (ts > chatState.lastTs) chatState.lastTs = ts;
          }
          const tempId = isPending ? ('tmp-' + Date.now() + '-' + Math.random().toString(16).slice(2)) : '';
          const wrapper = document.createElement('div');
          wrapper.className = 'chat-line';
          if (isPending) wrapper.classList.add('pending');
          const role = message.role || 'user';
          wrapper.dataset.role = role;
          wrapper.dataset.senderName = message.senderName || '';
          wrapper.dataset.senderId = message.senderId || '';
          if (role === 'system') {
            wrapper.classList.add('system');
          } else if (role === 'ai') {
            wrapper.classList.add('ai');
          } else if (String(message.senderId || '') === String(state.user.id || '')) {
            wrapper.classList.add('me');
          } else {
            wrapper.classList.add('other');
          }
          if (tempId) wrapper.dataset.tempId = tempId;
          if (!isPending && ts) wrapper.dataset.ts = String(ts);
          const bubble = document.createElement('div');
          bubble.className = 'chat-bubble';
          bubble.innerHTML = formatChatText(message);
          const meta = document.createElement('div');
          meta.className = 'chat-meta';
          meta.textContent = buildChatMeta(channel, message, ts, isPending);
          const contentWrap = document.createElement('div');
          contentWrap.className = 'chat-content';
          contentWrap.appendChild(bubble);
          contentWrap.appendChild(meta);
          const avatarUrl = role === 'ai' ? (state.aiAvatarUrl || publicConfig.aiAvatarUrl || DEFAULT_AI_AVATAR) : '';
          if (avatarUrl) {
            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            avatar.style.backgroundImage = `url('${avatarUrl}')`;
            wrapper.appendChild(avatar);
            wrapper.classList.add('with-avatar');
          }
          wrapper.appendChild(contentWrap);
          logEl.appendChild(wrapper);
          logEl.scrollTop = logEl.scrollHeight;
          if (!isPending && channel === 'ai') {
            recordAiTranscript(message, ts);
          }
          if (!isPending && channel === 'ai' && role === 'ai') {
            setAiPending(false);
            setAiLoading(false);
          }
          if (isPending) {
            chatState.pending[tempId] = wrapper;
          }
          return { tempId: tempId, element: wrapper };
        }

        function formatChatText(message){
          const text = String(message.text || '');
          if (!text) return '';
          if (message.role === 'ai' || message.role === 'system') {
            return linkifyHtml(renderMarkdown(text));
          }
          return linkifyPlainText(text);
        }

        function cleanAnchorArtifacts(str){
          let working = String(str || '');
          // 제거: 모델이 삽입한 불필요한 target/rel 속성 조각
          working = working.replace(/"\s*target="_blank"[^>]*>/gi, '');
          // 제거: URL 뒤에 남은 따옴표/속성 꼬리
          working = working.replace(/(https?:\/\/[^\s<>"']+)"[^\s<>"']*/g, '$1');
          return working;
        }

        function linkifyPlainText(str){
          const escaped = escapeHtml(cleanAnchorArtifacts(str || ''));
          const withLinks = escaped.replace(/(https?:\/\/[^\s<>"']+[^\s<>"'.,;:)\]])/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
          return withLinks.replace(/\n/g, '<br/>');
        }

        function linkifyHtml(str){
          if (!str) return '';
          const cleaned = cleanAnchorArtifacts(str);
          return cleaned.replace(/(https?:\/\/[^\s<>"']+[^\s<>"'.,;:)\]])/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        function getAiLogElementForStage(stage){
          const s = Number(stage || state.stage || 1);
          return $(s >= 4 ? 'finalChatLog' : 'aiChatLog');
        }

        function getAiUiRefs(){
          const stage = Number(state.stage || 1);
          const isFinal = stage >= 4;
          return {
            stage,
            isFinal,
            input: $(isFinal ? 'finalChatInput' : 'aiInput'),
            sendBtn: $(isFinal ? 'btnFinalChatSend' : 'btnAiSend'),
            loader: $(isFinal ? 'finalChatLoader' : 'aiChatLoader'),
            logEl: getAiLogElementForStage(stage),
          };
        }

        function escapeHtml(str){
          if (typeof str !== 'string') return '';
          return str.replace(/[&<>"']/g, function(ch){
            switch (ch) {
              case '&':
                return '&amp;';
              case '<':
                return '&lt;';
              case '>':
                return '&gt;';
              case '"':
                return '&quot;';
              case '\'':
                return '&#39;';
              default:
                return ch;
            }
          });
        }

        function extractFootnoteLinks(rawText){
          const footnotes = {};
          String(rawText || '')
            .split('\n')
            .forEach((line) => {
              const match = line.match(/^\s*\[?(\d+)\]?\s*[:\-–]?\s*(https?:\/\/[^\s)]+[^\s.,;:)\]]?)/i);
              if (match && match[1] && match[2]) {
                const num = match[1];
                const url = match[2].replace(/[)\]]+$/, '');
                if (url) footnotes[num] = url;
              }
            });
          return footnotes;
        }

        function renderMarkdown(text){
          if (!text) return '';
          const cleaned = cleanAnchorArtifacts(text);
          const footnotes = extractFootnoteLinks(cleaned);
          const codeBlocks = [];
          let working = cleaned.replace(/```([\s\S]*?)```/g, function(_match, code){
            const placeholder = `@@CODE_BLOCK_${codeBlocks.length}@@`;
            codeBlocks.push(`<pre><code>${escapeHtml(code)}</code></pre>`);
            return placeholder;
          });
          // 각주 번호를 링크 플레이스홀더로 먼저 치환해, 이후 escape 후에도 복원 가능하게 함
          working = working.replace(/\[([0-9]+)\]/g, function(match, num){
            return footnotes[num] ? `@@FOOTNOTE_${num}@@` : match;
          });
          working = escapeHtml(working);
          working = working.replace(/`([^`]+)`/g, (_match, code) => `<code>${code}</code>`);
          working = working.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
          working = working.replace(/__(.+?)__/g, '<strong>$1</strong>');
          working = working.replace(/\*(?!\s)([^*]+)\*/g, '<em>$1</em>');
          working = working.replace(/_(?!\s)([^_]+)_/g, '<em>$1</em>');
          working = working.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
          working = working.replace(/(https?:\/\/[^\s<]+[^<.,;:)\s])/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
          working = convertMarkdownLists(working);
          working = working.replace(/\n{2,}/g, '<br/><br/>').replace(/\n/g, '<br/>');
          codeBlocks.forEach((block, idx) => {
            working = working.replace(`@@CODE_BLOCK_${idx}@@`, block);
          });
          Object.keys(footnotes).forEach((num) => {
            const url = footnotes[num];
            const safeUrl = String(url).replace(/"/g, '&quot;');
            working = working.replace(
              new RegExp(`@@FOOTNOTE_${num}@@`, 'g'),
              `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">[${num}]</a>`
            );
          });
          return working;
        }

        function convertMarkdownLists(str){
          const unordered = str.replace(/(^|\n)([-*]\s.+(?:\n[-*]\s.+)*)/g, function(match, prefix, body){
            const lines = body
              .split('\n')
              .map((line) => line.replace(/^[-*]\s+/, '').trim())
              .filter(Boolean);
            if (!lines.length) return match;
            return `${prefix}<ul>${lines.map((item) => `<li>${item}</li>`).join('')}</ul>`;
          });
          return unordered.replace(/(^|\n)(\d+\.\s.+(?:\n\d+\.\s.+)*)/g, function(match, prefix, body){
            const lines = body
              .split('\n')
              .map((line) => line.replace(/^\d+\.\s+/, '').trim())
              .filter(Boolean);
            if (!lines.length) return match;
            return `${prefix}<ol>${lines.map((item) => `<li>${item}</li>`).join('')}</ol>`;
          });
        }

        function confirmChatMessage(channel, tempId, serverTs, original){
          const chatState = channel === 'ai' ? state.aiChat : state.peerChat;
          if (!chatState || !chatState.pending) return;
          const el = chatState.pending[tempId];
          if (!el) return;
          delete chatState.pending[tempId];
          el.classList.remove('pending');
          el.dataset.ts = String(serverTs);
          const dedupeKey = buildChatDedupeKey(original || {}, serverTs);
          chatState.rendered[dedupeKey] = true;
          chatState.lastTs = Number(serverTs) || chatState.lastTs;
          const meta = el.querySelector('.chat-meta');
          if (meta) {
            meta.textContent = buildChatMeta(channel, original || { role: 'user', senderName: state.user.name, senderId: state.user.id }, serverTs, false);
          }
          if (channel === 'ai' && original) {
            const messageWithStage = {
              ...original,
              ts: serverTs,
              ext: original.ext || { stage: original.stage || state.stage },
            };
            recordAiTranscript(messageWithStage, serverTs);
          }
        }

        function buildChatMeta(channel, message, ts, pending){
          let name = '';
          if (message.role === 'ai') {
            const stageNum = Number(state.stage || 1);
            if (stageNum === 2) name = '토론 상대'; // 3-1차시
            else if (stageNum === 3) name = '토론 성찰 지원 AI'; // 3-2차시 성찰
            else name = channel === 'ai' ? 'ChatGPT' : 'AI';
          }
          else if (message.role === 'system') name = '시스템';
          else name = message.senderName || message.senderId || '사용자';
          return name + ' · ' + (pending ? '전송 중...' : formatTime(ts));
        }

        function pollAiMessages(){
          if (!hasGas || !state.aiChat.sessionId) return;
          const stage = Number(state.stage || 1);
          if (!isAiChatStage(stage)) return;
          if (state.aiChat.fetching) return;
          state.aiChat.fetching = true;
          google.script.run.withSuccessHandler(function(list){
            state.aiChat.fetching = false;
            if (!Array.isArray(list)) return;
            list.forEach(function(msg){ appendChatMessage('ai', msg, { pending: false }); });
          }).withFailureHandler(function(err){
            state.aiChat.fetching = false;
            console.error(err);
          }).getMessages(state.aiChat.sessionId, state.aiChat.lastTs, 'ai-feedback');
        }

        function startAiPolling(){
          if (state.timers.ai) return;
          const stage = Number(state.stage || 1);
          if (!isAiChatStage(stage)) return;
          state.timers.ai = setInterval(pollAiMessages, 5000);
          pollAiMessages();
        }

        function stopAiPolling(){
          if (state.timers.ai) {
            clearInterval(state.timers.ai);
            state.timers.ai = null;
          }
        }

        function pollPeerMessages(){
          if (!hasGas || !state.peerChat.sessionId) return;
          const stage = Number(state.stage || 1);
          if (!isPeerChatStage(stage)) return;
          if (state.peerChat.fetching) return;
          state.peerChat.fetching = true;
          google.script.run.withSuccessHandler(function(list){
            state.peerChat.fetching = false;
            if (!Array.isArray(list)) return;
            list.forEach(function(msg){ appendChatMessage('peer', msg, { pending: false }); });
          }).withFailureHandler(function(err){
            state.peerChat.fetching = false;
            console.error(err);
          }).getMessages(state.peerChat.sessionId, state.peerChat.lastTs, 'peer-chat');
        }

        function startPeerPolling(){
          if (state.timers.peer) return;
          const stage = Number(state.stage || 1);
          if (!isPeerChatStage(stage)) return;
          state.timers.peer = setInterval(pollPeerMessages, 5000);
          pollPeerMessages();
        }

        function stopPeerPolling(){
          if (state.timers.peer) {
            clearInterval(state.timers.peer);
            state.timers.peer = null;
          }
        }

        function refreshSessionState(){
          if (!hasGas || !state.sessionKey || state.refreshingState) return;
          state.refreshingState = true;
        google.script.run.withSuccessHandler(function(res){
            state.refreshingState = false;
            syncSessionState(res);
          }).withFailureHandler(function(err){
            state.refreshingState = false;
            console.error(err);
          }).getSessionState(state.sessionKey);
        }

        function startStatePolling(){
          if (state.timers.state) return;
          state.timers.state = setInterval(refreshSessionState, 5000);
        }

        function startPresencePing(){
          if (state.timers.presence) return;
          state.timers.presence = setInterval(sendPresencePing, 10000);
        }

        function sendPresencePing(){
          if (!hasGas || !state.sessionKey) return;
          try { google.script.run.touchPresence(state.sessionKey); } catch (e) { console.error(e); }
        }

        function ensurePollers(){
          if (!state.sessionKey) return;
          startStatePolling();
          startPresencePing();
          const stage = Number(state.stage || 1);
          const isAiStage = isAiChatStage(stage);
          const isPeerStage = isPeerChatStage(stage);
          if (isAiStage && state.aiChat.sessionId) startAiPolling(); else stopAiPolling();
          if (isPeerStage && state.peerChat.sessionId) startPeerPolling(); else stopPeerPolling();
        }

        function clearAllTimers(){
          ['ai','peer','state','presence'].forEach(function(key){
            if (state.timers[key]) {
              clearInterval(state.timers[key]);
              state.timers[key] = null;
            }
          });
        }

        function clearChatLog(channel, options){
          const opts = options || {};
          if (channel === 'ai') {
            const aiLog = $('aiChatLog');
            const finalLog = $('finalChatLog');
            if (aiLog) aiLog.innerHTML = '';
            if (finalLog) finalLog.innerHTML = '';
          } else {
            const logEl = $('peerChatLog');
            if (logEl) logEl.innerHTML = '';
          }
          const chatState = channel === 'ai' ? state.aiChat : state.peerChat;
          if (!opts.keepLastTs) {
          chatState.lastTs = 0;
          }
          chatState.rendered = {};
          chatState.pending = {};
          chatState.fetching = false;
          if (channel === 'ai') {
            chatState.awaitingResponse = false;
            chatState.welcomeShown = false;
          }
        }

        function setStatus(message, type){
          state.status = { message: message, type: type || 'info' };
          const bar = $('statusBar');
          if (!bar) return;
          bar.textContent = message;
          bar.className = 'status-bar ' + (type || 'info');
        }

        function handleError(err){
          let msg = err && err.message ? err.message : (typeof err === 'string' ? err : '알 수 없는 오류가 발생했습니다.');
          if (msg.includes('429') || msg.includes('rate limit') || msg.includes('quota')) {
            msg = '요청이 너무 많습니다. 잠시 후 다시 시도해주세요.';
          }
          console.error(err);
          setStatus(msg, 'error');
        }

        function formatDate(ms){
          if (!ms) return '';
          return new Date(ms).toLocaleString('ko-KR', { hour12: false });
        }

        function formatTime(ms){
          if (!ms) return '';
          return new Date(ms).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
        }

        function formatStageName(step){
          const label = getStageLabel(step);
          return label?.name || `단계 ${step}`;
        }

        function describePresence(info){
          if (!info) return '오프라인';
          if (info.online) return '온라인 · ' + formatRelative(info.lastSeen || Date.now());
          if (info.lastSeen) return '오프라인 · 마지막 접속 ' + formatRelative(info.lastSeen);
          return '오프라인';
        }

        function formatRelative(ms){
          if (!ms) return '';
          const diff = Date.now() - ms;
          if (diff < 0) return '방금';
          const seconds = Math.floor(diff / 1000);
          if (seconds < 60) return '방금';
          const minutes = Math.floor(seconds / 60);
          if (minutes < 60) return minutes + '분 전';
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + '시간 전';
          const days = Math.floor(hours / 24);
          return days + '일 전';
        }

        function loadPublicSettings(){
          if (!hasGas) return;
          try {
            google.script.run.withSuccessHandler(function(cfg){
              if (!cfg) return;
              publicConfig.aiAvatarUrl = cfg.aiAvatarUrl || DEFAULT_AI_AVATAR;
              publicConfig.promptContent = cfg.promptContent || '';
              publicConfig.uiText = normalizeUiText(cfg.uiText, publicConfig.uiText || DEFAULT_UI_TEXT);
              publicConfig.stageLabelsByType[TYPE_KEYS.TYPE_A] = normalizeStageLabels(
                cfg.stageLabels,
                DEFAULT_STAGE_LABELS_BY_TYPE[TYPE_KEYS.TYPE_A]
              );
              publicConfig.stagePromptsByType[TYPE_KEYS.TYPE_A] = normalizeStagePrompts(
                cfg.stagePrompts,
                DEFAULT_STAGE_PROMPTS_BY_TYPE[TYPE_KEYS.TYPE_A]
              );
              publicConfig.panelCopyByType[TYPE_KEYS.TYPE_A] = normalizePanelCopy(
                cfg.panelCopy,
                publicConfig.panelCopyByType[TYPE_KEYS.TYPE_A]
              );
              state.aiAvatarUrl = publicConfig.aiAvatarUrl || DEFAULT_AI_AVATAR;
              buildStepIndicator();
              applyStageLabelsToPanels();
              applyUiText();
              renderStagePrompts();
              updateStepIndicator();
              renderRightPanels();
            }).getPublicSettings();
          } catch (e) {
            console.error(e);
          }
        }

        init();
      })();
    </script>
  </body>
</html>

 